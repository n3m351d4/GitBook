---
description: 'Перевод: @beh1ndy0urback 07/2021'
---

# Как работает протокол последовательной передачи данных?

Как вы уже знаете, последовательный протокол использует два канала - RX и TX. Данные в этих каналах кодируются одинаково. Когда какой либо канал неактивен \(т.е. данные не передаются\), для канала установлен высокий логический уровень.

Последовательный протокол работает c несколькими параметрами, которые нам показывает `picocom`, когда мы запускаем консоль:

```text
$ picocom /dev/ttyACM0 -b 115200
picocom v3.1

port is        : /dev/ttyACM0
flowcontrol    : none
baudrate is    : 115200
parity is      : none
databits are   : 8
stopbits are   : 1
```

Кадр или фрейм последовательного протокола выглядит примерно так:

| **Стартовый бит** | **Биты данных** | **Бит четности** | **Стоповый бит** |
| :--- | :--- | :--- | :--- |
| Всегда один бит | Количество битов данных | Один бит для исправления ошибок | Количество стоповых бит |
| Всегда “низкий” | “Высокий”, если “1”, “низкий”, если “0”  | Зависит от алгоритма | Всегда “высокий” |

Параметры, управляющие количеством битов, называются D \(Data - для битов данных\), P \(Parity - для битов чётности\) и S \(Stop - для стоповых бит\). Значения по умолчанию:

* D = 8 бит
* P = N \(No - нет бита чётности\)
* S = 1 бит

Это самые распространенные значения, но реализации последовательного протокола могут быть разными и могут использовать другие значения. ЦП ATMega использует значения по умолчанию, что значит, что каждый фрейм будет начинаться с одного стартового бита \(“низкого”\), затем последуют 8 бит данных \(“низких”/”высоких”\) и один бит будет стоповый \(“высокий”\).

Привычный способ записать параметры - разделить их косой чертой \(например, `8/N/1`\) или просто записать их в `DPS`-порядке - `8N1`. Бит чётности \(средний параметр, parity\) задается символом, относящимся к алгоритму обнаружения ошибок.

Посмотрим на нашу захваченную последовательность и попробуем расшифровать первый фрейм \(8 бит = 1 байт\). Программное обеспечение Logic содержит анализатор последовательного протокола, что очень удобно для нас. Чтобы включить его, щелкните значок “`+`” рядом с “`Analysers`” и выберите “`Async serial`”. В открывшемся окне выберите “Channel 1” и установите флажок “Use autobaud” \(чуть позже я всё это объясню\). Остальные параметры оставьте как есть. Окно должно выглядеть примерно так: 

![Serial analyser settings](https://maldroid.github.io/hardware-hacking/assets/logic-screenshot-analyzer.png)

Теперь в строке “Channel 1” должны появиться синие прямоугольники и несколько точек на графике минимумов и максимумов, вот так:

![Decoded serial protocol](https://maldroid.github.io/hardware-hacking/assets/logic-screenshot-decoded-serial.png)

Синее поле содержит символ ASCII, который, по мнению Logic, здесь закодирован и отправлен, а точки означают биты данных. Изображение снизу дополнено комментариями и показывает, как можно декодировать один фрейм последовательного протокола:

![Decoded and annotated serial protocol](https://maldroid.github.io/hardware-hacking/assets/logic-screenshot-decoded-serial-annotated.png)

Как мы видим и, как вы, вероятно, заметили при настройке анализатора, младший бит отправляется первым \(least significant bit sent first\). Это означает, что считать следует с последнего отправленного бита. Так же вы можете различить начальный и стоповый биты.  

Осталось последнее: как узнать, какую именно длину имеет бит? В нашем случае передача начинается со стартового \(младшего\) бита и четырех нулей. Это значит, что линия довольно долго остается низкой и мы не знаем, сколько в ней битов. Здесь пригодится алгоритм “autobaud”.

Если мы не знаем точную длину одного бита \(которая измеряется количеством бит в секунду, bit per second - bps\), мы можем ее угадать. Принцип алгоритма угадывания прост: сначала мы предполагаем, что первый “низкий” период равен одному биту, затем переходим к следующему “низкому” периоду, и если он короче, то мы предполагаем, что это длина одного бита, и так далее, до конца передачи.

В анализаторе вы можете увидеть длину любого периода, просто наведя на него курсор:

![Bit length in seconds](https://maldroid.github.io/hardware-hacking/assets/logic-bit-length.png)

Здесь видно, что длина периода равна 8,400 микросекунд, что значит, что скорость передачи составляет:

![](https://render.githubusercontent.com/render/math?math=1/%20%288.4%20\mu%20s%29%20=%20119,047%20bps)

Если вы нажмете на шестеренку рядом с “`Async serial`” и выберете “`Edit settings`”, то увидите, что мы правильно вычислили скорость передачи данных:

![Autobaud guess](https://maldroid.github.io/hardware-hacking/assets/logic-analyser-autobaud.png)

Теперь, когда у нас есть всё, что нужно знать о последовательном протоколе, пора взглянуть на тайминги проверки пароля \(вы же ещё помните эту часть?\)

