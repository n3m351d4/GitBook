---
description: 'Перевод: @beh1ndy0urback 07/2021'
---

# Добро пожаловать!

[**Источник**](https://maldroid.github.io/hardware-hacking/)\*\*\*\*

Этот курс демонстрирует основы в области аппаратного обеспечения. Всё, что вам нужно - компьютер под управлением Linux, macOS или Windows. Дополнительного оборудования, особых навыков или опыта **НЕ** требуется. Все примеры демонстрируются на плате Arduino Uno, и если у вас она есть - можете воспроизвести примеры самостоятельно, но в этом нет необходимости. Обещаю будет немножко весело.

Перед началом скачайте и установите анализатор [Logic от Saleae](https://www.saleae.com/downloads/) и сделайте себе кружку чая \(или любого другого напитка на свой вкус, даже не обязательно в кружке\).

> Совет: если какие-то изображения покажутся вам слишком мелкими для чтения, просто кликните по ним правой кнопкой мыши и выберите «открыть изображение в новой вкладке».

## **Проверка пароля.**

Наша задача проста. У нас есть плата Arduino Uno с процессором 16 МГц. Мы предполагаем, что память \(включая код, работающий на этом устройстве\) недоступна для атакующего.

Нам нужно написать метод проверки пароля, который в качестве аргумента принимает строку и возвращает `true`, если строка соответствует жестко установленному паролю из 5 символов, и `false` в противном случае. Пароль жестко запрограммирован и не хеширован, но все методы, представленные здесь, являются достаточно обобщенными, чтобы работать в различных конфигурациях. ****Наша первая попытка, вероятно, будет примерно такой \(`loop` в Arduino аналогичен `main` в обычном C\):

```text
String PASSWORD = "passw";

bool checkPass(String buffer) {
  for (int i = 0; i < PASSWORD.length(); i++) {
    if (buffer[i] != PASSWORD[i]) {
      return false;
    }
  }
  return true;
}

void loop() {
  Serial.print("Password:");
  char pass[PASSWORD.length()];
  Serial.readBytes(pass, PASSWORD.length());
  bool correct = checkPass(pass);
  if (correct) {
    Serial.println("Password correct!");
    Serial.flush(); exit(0);
  } else {
    Serial.println("Incorrect password!");
  }
}
```

Давайте разберемся, что делает этот код. Сначала он запрашивает пароль, затем пытается прочитать столько байтов, сколько составляет длина пароля. После этого запускается метод `checkPass` - он перебирает байт за байтом пароля. Если один из байтов ввода не соответствует фактическому паролю, метод возвращает `false` и сообщение “`Incorrect password!`”.

Если же каждый введенный байт соответствует паролю, метод `checkPass` возвращает `true`, и мы получаем сообщение "`Password correct!`".

Пароль состоит из 5 символов, а процессор работает на частоте 16 МГц, что делает брутфорс практически невозможным, так как на него потребуются годы. Одна попытка подбора занимает примерно 62,5 микросекунды. Итого мы получим:

![&#x427;&#x443;&#x442;&#x44C; &#x431;&#x43E;&#x43B;&#x44C;&#x448;&#x435; &#x434;&#x432;&#x443;&#x445; &#x43B;&#x435;&#x442;.](https://render.githubusercontent.com/render/math?math=256^5\times%2062.5\mu%20s%20=%2068,719,476.7s%20=%202.17%20years)

Если вы все еще сомневаетесь, то перебор это просто долго и скучно. В целом этот код теоретически должен работать нормально. Однако этот курс посвящен взлому оборудования и мы подходим к первому вопросу:

Что не так с этим кодом с точки зрения взлома оборудования? Как физический доступ к устройству может облегчить взлом пароля?

