---
description: '2020'
---

# Hardware Hacking: Основы работы с GNU Radio

_`Перевела @ZzzNein (безграничную благодарность можно выразить`_ [_`ЗДЕСЬ`_](https://yasobe.ru/na/na_perevody_i_kontent)_`), проверила @N3M351DA.`_ [_`Оригинальный текст`_](https://www.blackhillsinfosec.com/gnu-radio-primer/) _`- Реймонд Фелч, 9 декабря 2019 г.`_

**Внимание!** При передаче любых данных обязательно используйте клетку Фарадея или экранированную сумку, чтобы случайно не нарушить каких-либо законов несанкционированным вмешательством в эфир на определенных частотах. Кроме того, помните, что перехват и дешифрование/декодирование чужих данных является незаконным, поэтому будьте осторожны при исследовании вашего трафика.

![](../../.gitbook/assets/image%20%28272%29.png)

##  **Предисловие**

Недавно я окунулся в мир SDR \(программно-определяемого радио\) и в процессе многому научился. Я выяснил, что могу не только эмулировать радиосигналы посредством применения различных программных средств и приложений \(например, SDR Sharp, GQRX, SIGINTOS, CubicSDR, ПО, поддерживающее RTL-SDR, и т.д.\), но и использовать потоковые графы GNU Radio, такие как ‘grgsm\_livemon.grc’, для захвата пакетов мобильной сети GSM в реальном времени.

Каким бы информативным и образовательным ни был этот проект, мне бы хотелось подробнее разобраться в схемах GNU Radio. Также хочется изучить основы создания таких графов, а не просто полагаться на чьи-то чужие примеры таковых, до конца не понимая, почему \(или как\) они работают.

Несмотря на то, что в сети можно найти довольно много документации, GNU Radio \(и в частности - GNURADIO-COMPANION\) может все еще представлять трудность и пугать юзеров при первом обращении. Немного поискав в Google, я в конце концов наткнулся на [онлайн-уроки Майкла Османа из Great Scott Gadgets](https://greatscottgadgets.com/sdr/%20) и, стоит сказать, они мне здорово помогли. Кроме того, [гайды по GNU Radio](https://wiki.gnuradio.org/index.php/Tutorials) помогли закрепить свежие знания.

Чтобы познакомиться с основами GNU Radio, я выбрал проект, который мог быть использован для рассмотрения атак методом повторения радиосигнала \(обнаружение, захват и воспроизведение необработанного радиочастотного сигнала \(далее – «RF-сигнал»\)\) и разблокировки моего Ford Mountaineer 1999 г. путем обхода частотно-регулируемой кнопки \(FOB\).

![](../../.gitbook/assets/image%20%28268%29.png)

Нужно заранее сказать, что, хотя я и смог захватить сигнал разблокировки с FOB и воспроизвести его \(с помощью HackRF\), автомобиль я не открыл. Дело в том, что много лет назад были внесены изменения с целью предотвращения упомянутых атак методом повторения радиосигнала. Использовалась техника непрерывно изменяющегося кода \(иногда называется «псевдослучайный код»\). 

Перед внесением обозначенного выше изменения автомобили и устройства открывания гаражных ворот использовали фиксированные коды, и атакующий с помощью соответствующего приемника мог обнаружить эти устройства. Злоумышленник получал данные для последующего использования. На момент написания этой статьи было уже много упоминаний об обходе непрерывно изменяющегося кода, включая использование методов глушения и сброса кода.

Тем не менее, я обнаружил, что работа над проектом стоила затраченных усилий. Она позволила лучше понять GNU Radio и дала приобрести необходимые знания для созданий собственных рабочих схем.

## **Основы** **GNU** **Radio** **и информация о схемах:**

* Вся обработка сигналов в GNU Radio выполняется с использованием схем, состоящих из отдельных блоков, каждый из которых выполняет всего одну операцию цифровой обработки сигнала: фильтрацию, дешифрование, мультиплексирование и т.д.
* Эти данные передаются между этими блоками в различных форматах, комплексных или вещественных целых числах, с плавающей запятой или просто в виде данных любого типа по вашему выбору.
* Каждой потоковой схеме требуется как минимум один исходный блок \(ввод\) и один блок-приемник \(вывод\).
* Источником или приемником может быть USB-донгл, HackRF, BladeRF, звуковая карта, файл или fft \([БПФ – быстрое преобразование Фурье](https://en.wikipedia.org/wiki/Fast_Fourier_transform)\), и это лишь некоторые из них. 

##  **Получение информации о моем** **FOB:**

Чтобы определить рабочую частоту моего FOB, я нашел номер FCC, который ассоциирован с моим брелоком. После поиска в Google, а затем поиска FCC, я получил следующую информацию:

![](../../.gitbook/assets/image%20%28270%29.png)

Результатом поиска по FCC была рабочая частота:

![](../../.gitbook/assets/image%20%28267%29.png)

Вооружившись данными о рабочей частоте моего устройства \(315 МГц\), я посчитал, что пора сделать попытку захвата сигнала «разблокировки автомобиля». В стандартной ситуации я мог бы использовать одно из многих доступных приложений \(SDR Sharp и т.д.\) для его отслеживания и захвата необработанных данных. Однако в данном случае я хотел смостоятельно создать схему GNU Radio.

Я перешел в директорию моих проектов и вызвал следующую команду:

```text
$ sudo gnuradio-companion 
```

После загрузки gnuradio-companion, я создал новую схему:

![](../../.gitbook/assets/image%20%28265%29.png)

Обратите внимание, что новая схема открывается уже с двумя блоками - «Опции» и «Переменная». «Опции» \(ID: top\_block\) определяют библиотеку цепочки инструментов, которую мы будем использовать: QT-GUI, WX-GUI, none, блок иерархии \(hier block\) и т.д. А блок «Переменной» \(ID: samp\_rate\) создан для выбора частоты дискретизации нашего сигнала, по умолчанию – 32 ksps \(32 тысяч выборок в секунду\).

**Примечание**: Щелкните правой кнопкой мыши по любому блоку, чтобы отобразить его свойства и сменить параметры.

![](../../.gitbook/assets/image%20%28269%29.png)

Я буду использовать HackRF \(с блоком osmocom\). Рекомендуемая минимальная частота дискретизации при использовании HackRF составляет 2M выборок в секунду. Я могу выбрать Источник osmocom, найдя и дважды кликнув по нему в списке.

![](../../.gitbook/assets/image%20%28271%29.png)

На данном этапе, если бы мне захотелось изменить переменную частоты дискретизации с 32k \(32e3\) \(по умолчанию\) на 2M \(2e6\), я бы мог это сделать. Любой блок схемы, содержащий переменную ‘samp\_rate’ теперь будет использовать новое \(скорректированное\) значение.

Также было бы очень полезно иметь переменную для центральной частоты 315 МГц \(315e6\). Этого легко добиться, скопировав и вставив блок переменных samp\_rate и присвоив новому блоку переменных имя center\_freq. 

![](../../.gitbook/assets/image%20%28266%29.png)

Теперь можно щелкнуть правой кнопкой мыши по блоку источника osmocom и сменить частоту канала CH0, заданную по умолчанию \(100e6\), чтобы она стала переменной «center\_freq». Моя схема теперь выглядит так:

![](../../.gitbook/assets/image%20%28273%29.png)

Обратите внимание, что за значениями двух переменных «samp\_rate» и «center\_freq» теперь следует блок источника osmocom. Определенные переменные очень удобны, поскольку размер потоковых графов увеличивается, а удобочитаемость затрудняется. 

Также обратите внимание на вывод источника osmocom, окрашенный в синий. Этот цвет указывает на комплексное значение \(действительное и мнимое\), которое будет предоставлено на выходе. Если бы цвет вывода был оранжевым, то на выходе было бы действительное значение \(целое, с плавающей запятой, абсолютное и т.д.\). Это важная концепция, о которой нужно знать. Цвета ввода и вывода должны совпадать, иначе будет выводиться ошибка. Несоответствия можно исправить, отредактировав свойство «Тип вывода» или «Тип ввода» блока.

Наконец, обратите внимание, что источник \(ID\) osmocom подсвечен красными буквами. GNU Radio использует этот цвет для обозначения ошибки в схеме. В этом случае ошибка относится к блоку Source, у которого отсутствует выходное соединение. Это можно обойти, если добавить выходной \(приемный\) блок и соединить два блока вместе.

