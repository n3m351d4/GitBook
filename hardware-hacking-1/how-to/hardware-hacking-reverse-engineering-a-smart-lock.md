---
description: Перевод @n3m351da @in51d3 2020 (Спасибо Славе за редактуру!)
---

# Hardware Hacking: Реверс умного замка

[Оригинальный текст](https://www.blackhillsinfosec.com/reverse-engineering-a-smart-lock/)

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image24.png)

## **Введение**

Недавно мне представилась возможность изучить результаты исследований фирмы F-Secure, которая обнаружила уязвимость в умном замке Guardtec KeyWe. Специалисты обнаружили, что злоумышленник может перехватить и расшифровать трафик, исходящий от владельца замка. Я нашел их статью чрезвычайно увлекательной и очень информативной. Вскоре у меня появился стимул посмотреть, смогу ли я повторить их результаты, так как F-Secure выпустила уведомление об уязвимости и поставщику была предоставлена возможность её исправить. К сожалению, исправить уязвимость было сложно, так как в замке отсутствовала функция обновления прошивки, поэтому вместо обновления прошивки была использована обфускация приложения для Android, в попытке скрыть наиболее важные разделы кода \(что они сделали довольно хорошо\).

Несмотря на то, что F-Secure заложили основу для этого исследования, они старались не раскрывать слишком много информации и даже ИЗМЕНЯЛИ некоторые из своих собственных инструментов.

После приобретения умного замка KeyWe и создания тестового окружения, я загрузил приложение для Android на свой мобильный телефон и создал учетную запись. Я познакомился с функциями замка и внешним видом мобильного приложения. Также я запустил мобильное приложение Nordic nRF Connect \(доступно в Google Play\), чтобы получить полезную информацию о моем замке - адрес Bluetooth, UUID и прочие характеристики.

**Примечание**. Спецификации BLE доступны [здесь](%20https://www.bluetooth.com/specifications/).

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image20.png)

## **Полезная информация**

Связь между KeyWe и приложением поддерживается через пакеты Bluetooth с низким энергопотреблением \(BLE\), которые шифруются с использованием стандартного шифра ECB AES-128 для предотвращения перехвата. Безопасность канала связи основана исключительно на **3 секретных ключах**, используемых для шифрования и дешифрования пакетов AES-128 OTA \(передаваемых по беспроводной сети\). 

* Общий ключ \(**CommonKey**\), используется для первоначального обмена ключами.
* Ключ приложения \(**AppKey**\), используется для шифрования пакетов, отправляемых приложением замку.
* Ключ замка \(**DoorKey**\), используется для шифрования пакетов, отправляемых замком в приложение.

## **Генерация ключа**

**CommonKey** основан на статическом 16-байтовом значении, которое начинается с последних 5 байт адреса Bluetooth устройства:

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image22.png)

После изучения CommonKey в нескольких устройствах KeyWe выяснилось, что во всех устройствах различаются только последние два байта адреса Bluetooth! Для моего устройства уникальными были значения 4C и 93. Это говорит о том, что CommonKey предсказуем! 

**AppKey** и **DoorKey** создаются при помощи двух сильно запутанных алгоритмов и методов makeAppKey и makeDoorKey. Сотрудники F-Secure создали инструмент, который генерирует три секретных ключа, моделируя эти два метода \(**makeAppKey** и **makeDoorKey**\). Однако по прошествии значительного времени я смог самостоятельно воссоздать эти методы, работая с инструментом с открытым исходным кодом под названием Frida \(подробнее об этом позже\).

Создание **AppKey** и **DoorKey** происходит путем передачи двух аргументов функциям **makeAppKey** и **makeDoorKey**. Этими двумя аргументами являются **AppNumber** и **DoorNumber** соответственно.

**AppNumber** - статическое 12-байтовое значение \(дополненное четырьмя нулевыми байтами\): 92 4b 03 5f bd a5 6a e5 ef 0e d0 5a 00 00 00 00 

**Примечание**: AppNumber зашифровывается с помощью CommonKey и отправляется замку для его блокировки, в качестве первого пакета пользовательского сеанса, тем самым инициируя начало сеанса.

**DoorNumber** - это динамическое \(изменяется каждый новый сеанс\) 12-байтовое значение \(дополненное четырьмя нулевыми байтами\), генерируемое замком. Это значение \(также зашифрованное с помощью **CommonKey**\) отправляется в приложение в ответ на **AppNumber** \(см. рисунок ниже\).

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 2. &#x414;&#x438;&#x430;&#x433;&#x440;&#x430;&#x43C;&#x43C;&#x430; &#x43F;&#x435;&#x440;&#x435;&#x434;&#x430;&#x447;&#x438; &#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x439; &#x448;&#x438;&#x444;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x44F;](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image4-3.png)

**Примечание**. Эти две передачи \(**AppNumber** и **DoorNumber**\) завершают процесс обмена ключами и позволяют создать **AppKey** и **DoorKey**, которые обеспечивают безопасную связь OTA между приложением и замком. 

Теперь, когда **AppNumber** и **DoorNumber** созданы, у нас есть два компонента, необходимые для генерации двух оставшихся секретных ключей \(**AppKey** и **DoorKey**\). Это достигается путем вызова функций makeAppKey и makeDoorKey с AppNumber и DoorNumber в качестве аргументов. Это делается внутри прошивки и никуда не отправляется.

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 3. &#x421;&#x445;&#x435;&#x43C;&#x430; &#x433;&#x435;&#x43D;&#x435;&#x440;&#x430;&#x446;&#x438;&#x438; &#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x439; AppKey &#x438; DoorKey](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image18.png)

## **Схема работы**

Теперь, после того, как мы сгенерировали ключи AppKey и DoorKey и между замком и приложением произошел обмен ключами, обе стороны могут шифровать / дешифровать отправленные или полученные пакеты. Все пакеты, передаваемые приложением, будут зашифрованы с использованием ключа приложения **AppKey**, а все пакеты, передаваемые замком, будут зашифрованы с помощью ключа замка. Обе стороны знают схемы шифрования друг друга и поэтому могут расшифровать пакет.

Следующий рисунок демонстрирует порядок событий сеанса:

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 4. &#x414;&#x438;&#x430;&#x433;&#x440;&#x430;&#x43C;&#x43C;&#x430; &#x442;&#x438;&#x43F;&#x43E;&#x432;&#x43E;&#x433;&#x43E; &#x441;&#x435;&#x430;&#x43D;&#x441;&#x430; &#x441;&#x432;&#x44F;&#x437;&#x438;](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image25.png)

Следует отметить, что все эти пакеты передаются в начале каждого сеанса, и все пакеты зашифрованы либо **AppKey**, либо **DoorKey** в зависимости от устройства, которому они предназначены.

## **Реверс Android приложения**

Все мобильные приложения загружаются в виде файлов APK \(Android Application Package\). Файлы APK сохраняются в формате ZIP и загружаются непосредственно на устройства Android, обычно через магазин Google Play, но их можно найти и на других веб-сайтах. При обратной разработке APK-файлов Android я обнаружил, что зачастую полезно использовать сторонние сайты для поиска более старых версий рассматриваемого APK. Мой любимый - [https://apkpure.com/](https://apkpure.com/).

**Требования к программному обеспечению**

* Java version 1.8.0\_251
* ADB \(android debug bridge\) version 1.0.41
* APKStudio \(wrapper for Apktool\) version 2.4.1
* Dex2Jar version 
* Jadx version 1.1.0
* Frida version 12.8.9

**Требования к оборудованию**

* Телефон на андроид с привилегиями пользователя root

Обычный APK-файл содержит множество файлов, например, файлы AndroidManifest.xml, classes.dex и resource.arsc; а также папку Meta-INF и res. Существует множество способов открыть APK. Очевидно, что поскольку это ZIP-файл, любой из архиваторов справится, однако использование специализированных инструментов, таких, как Dex2Jar, Apktool и Jadx, представит дополнительные преимущества, например, позволит преобразовать файлы .dex в Java-код или предоставит удобный графический интерфейс.

Файлы DEX \(исполняемые файлы Dalvik\) — это файлы разработчика, используемые для инициализации и исполнения приложений мобильной платформы Android. Такие инструменты, как Apktool, могут декомпилировать файлы DEX с языка машинных инструкций в файлы Smali. Также, можно использовать dex2jar, для преобразования файлов DEX в файлы JAR \(java\), использовать графический интерфейс jadx для открытия файлов JAR как исходного кода java. Исходный код Java намного проще читать, чем исходный код Smali. Существует множество инструментов для работы с APK-файлами, мой любимый - APKStudio.

Описание любого из вышеперечисленных инструментов, выходит за рамки статьи. Я бы посоветовал загрузить их и поэкспериментировать с разными утилитами, чтобы найти наиболее подходящие для себя, а так же почитать соответствующие руководства.

## **Использование FRIDA** 

Исследователи F-Secure написали в своем блоге, что им удалось перехватить вызовы функций в приложении для Android с помощью инструмента под названием Frida. Я не знал об этом инструменте, поэтому решил изучить его. Эта утилита просто потрясающая! Понимание того, как использовать Frida, выходит за рамки этой статьи. Однако достаточно сказать, что Frida позволяет исследователю подключаться к существующим функциям в приложении и динамически выгружать аргументы и возвращаемые значения. Это определенно стоит попробовать! [https://frida.re/docs/home/](https://frida.re/docs/home/)

**Установка Frida**

```text
pip install frida
pip install frida-tools
```

**Необходимо**

* frida-server и ****adb \(android debug bridge\)
* Телефон на андроиде с привилегиями пользователя root

**Установка frida-server на телефон**

Чтобы установить сервер, перейдите по адресу [https://github.com/frida/frida/releases](https://github.com/frida/frida/releases) и загрузите файл, подходящий к вашей платформе.

Если вы не знаете архитектуру своего телефона, то скачайте и запустите приложение **Droid Hardware Info** \(из Google Play\)

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 5. &#x412;&#x44B;&#x431;&#x43E;&#x440; &#x430;&#x440;&#x445;&#x438;&#x442;&#x435;&#x43A;&#x442;&#x443;&#x440;&#x44B; Frida](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image23.png)

* Скопируйте загруженный файл в директорию своего проекта
* Откройте эту директорию
* Разархивируйте файл .xz: **xz -d -k frida-server-12.9.8-android-arm.xz**
* Используя adb \(android debug bridge\) отправьте извлеченный файл на свой телефон

**Начальная настройка**: \(установка frida-server на телефон\)

```text
$ adb push frida-server-12.9.4-android-arm /data/local/tmp
$ adb shell     ### shell into phone
$ su                                    
# cd /data/local/tmp
# chmod 777 frida-server
# ./frida-server &              
```

Как только frida-server установлен на телефоне, запустите новый сеанс следующим образом:

```text
$ adb shell
$ su
# cd /data/local/tmp
# ./frida-server &
```

Мне было трудно одновременно изучать Frida и искать вызовы функций, на которые F-Secure ссылались в своих блогах. Из-за рекомендаций F-Secure поставщик сильно обфусцировал последние версии приложения, что означало отсутствие функций **makeAppKey** или **makeDoorKey**. Я также обнаружил, что поставщик включил меры безопасности для предотвращения запуска приложения **KeyWe** на телефонах с доступом к root. Исследователи F-Secure создали классный инструмент используя Python и javascript: позволяя присоединять Frida к методу, вызывающему ошибку, а также внедрили код, который всегда возвращал false для метода **isRooted**.

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 6. &#x424;&#x440;&#x430;&#x433;&#x43C;&#x435;&#x43D;&#x442; &#x43A;&#x43E;&#x434;&#x430;, &#x43E;&#x43F;&#x440;&#x435;&#x434;&#x435;&#x43B;&#x44F;&#x44E;&#x449;&#x438;&#x439; &#x43F;&#x440;&#x438;&#x432;&#x438;&#x43B;&#x435;&#x433;&#x438;&#x438; root](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image12-2.png)

К сожалению, из-за обфускации нового приложения класс «RootTool» перестал существовать, и мне пришлось искать в коде эквивалент. После долгого поиска кода я в конце концов нашел методы проверки наличия привилегий root. Оказалось, что класс «RootTool» теперь упоминается как «n», а функция «iSRooted» теперь упоминается как функция «b».

**Модифицированный скрипт F-Secure’s KeyWe-Tooling** 

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 7. &#x423;&#x441;&#x43F;&#x435;&#x448;&#x43D;&#x44B;&#x439; &#x43E;&#x431;&#x445;&#x43E;&#x434; &#x434;&#x435;&#x442;&#x435;&#x43A;&#x442;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x44F; &#x43D;&#x430;&#x43B;&#x438;&#x447;&#x438;&#x44F; root &#x43F;&#x440;&#x430;&#x432;](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image7-2.png)

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 8. &#x418;&#x437;&#x43C;&#x435;&#x43D;&#x435;&#x43D;&#x438;&#x435; &#x43C;&#x435;&#x442;&#x43E;&#x434;&#x43E;&#x432; &#x434;&#x435;&#x442;&#x435;&#x43A;&#x442;&#x438;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x438;&#x44F; root-&#x43F;&#x440;&#x430;&#x432;](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image1-4.png)

Работать с последней версией приложения стало в разы сложнее, чем это того стоило. Разбор обфусцированного кода становился чрезвычайно утомительным в попытках найти функции, имена которых были изменены на одну букву. К счастью, примерно в это же время коллега дал мне ссылку на несколько более старых APK-файлов Android KeyWe [https://apkpure.com/keywe-for-a-smarter-life/com.guardtec.keywe/versions](https://apkpure.com/keywe-for-a-smarter-life/com.guardtec.keywe/versions). Это оказалось отличной находкой, так как теперь я мог найти версию, со всеми функциями, на которые были ссылки. Я вернулся к исходной \(не модифицированной\) версии сценария сокрытия root-прав от F-Secure, и это сработало! Кроме того, у меня заработал их скрипт «trace\_java\_functions», предоставляя мне огромное количество данных.

В следующем примере шестнадцатеричного дампа Frida мы видим, как выполняется вызов функции шифрования AES-128, передающей два аргумента byte\_array \(**AppNumber**, **CommonKey**\). Она шифрует **AppNumber** с помощью **CommonKey** для передачи OTA-пакета замку в начале сеанса.

Аналогичным образом, показан вызов функции шифрования AES-128 с передачей аргументов \(**DoorNumber**, **CommonKey**\) для шифрования **DoorNumber** для передачи OTA в приложение. 

Frida позволяет увидеть переданные аргументы и возвращаемые значения двух внутренних вызовов функций, которые генерируют **AppKey** и **DoorKey**.

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 9. &#x41F;&#x440;&#x438;&#x43C;&#x435;&#x440; &#x434;&#x430;&#x43C;&#x43F;&#x430; c &#x43F;&#x43E;&#x43C;&#x43E;&#x449;&#x44C;&#x44E; Frida](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image15.png)

Основываясь на множестве записанных сессий Frida и расшифровке данных, я вскоре разобрался с работой приложения KeyWe и понял, как и где генерируются ключи, а также разобрался в последовательности событий при запуске. Кроме того, я узнал, что во время активного сеанса состояние замка постоянно отслеживается и обновляется посредством обмена информацией между приложением и замком. Разобранные мной сеансы включали в себя вход в систему, разблокировку и блокировку замка с помощью приложения на моем телефоне.

**Java скрипты F-Secure для Frida :**

* Обход обнаружения наличия рут-прав:  disable\_root\_detection.js
* Трассировка внедренных java-функций:  trace\_java\_functions.js  \(original\)

**Сессия включает следующие действия:** 

* Вход, ожидание соединения и появления статуса "заблокировано" LOCKED
* Нажатие на кнопку "разблокировать", ожидание, нажатие на кнопку "заблокировать", ожидание
* Нажатие на кнопку "разблокировать", ожидание авторазблокировки, разъединение

C:\Users\rayfe\keywe-tooling\frida&gt;**start\_root.py**                                                                     ****    ****

C:\Users\rayfe\keywe-tooling\frida&gt;**keywe\_inject.py trace\_java\_functions.js**

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 10. &#x41F;&#x440;&#x438;&#x43C;&#x435;&#x440; &#x440;&#x430;&#x431;&#x43E;&#x442;&#x44B; &#x441;&#x446;&#x435;&#x43D;&#x430;&#x440;&#x438;&#x435;&#x432;](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image19.png)

## **BTSNOOP \(ANDROID BLUETOOTH логгер\)**

BTSNOOP одна из моих лучших находок, для захвата сеанса Bluetooth между телефоном и периферией, я пытался это делать различными методами, например, платами nRF Sniffer Nordic nRF52840-DK, Sena UD100, донглом Ubertooth-One и Texas Instruments CC2540. Проблема всех этих подходов состоит в том, что они не могли отслеживать соединение из-за переключения каналов Bluetooth Low Energy \(BLE\).

**НЕИСПРАВНОСТЬ NRF SNIFFER!** 

Замок KeyWe выполняет смену канала после сопряжения, и nRF пропускает начальный обмен ключами безопасности CCM AES-128 BLE. Это приводит к получению зашифрованных «бесполезных» пакетов. Это  существенный недостаток nRF Sniffer. 

_Примечание_. CCM AES-128 BLE - это протокол безопасности, который используется во всех беспроводных соединениях Bluetooth Low Energy OTA для предотвращения MiTM. 

**Обмен ключами безопасности CCM AES-128 BLE:** \(это общая информация, не имеющая отношения к проекту KeyWe\) .

Временный ключ используется в процессе сопряжения Bluetooth. Краткосрочный ключ используется в качестве ключа для шифрования соединения при первом сопряжении устройств. Краткосрочный ключ генерируется с использованием трех частей: временного ключа и двух случайных чисел, одно генерируется ведомым устройством, а другое - ведущим. После того, как соединение зашифровано краткосрочным ключом, остальные ключи меняются: долгосрочный ключ заменяет краткосрочный ключ для шифрования соединения. Ключ личности используется для конфиденциальности. Ключ подписи подключения используется для аутентификации.

## СПОСОБ ПЕРЕХВАТА ТРАФИКА BLUETOOTH С ПОМОЩЬЮ УСТРОЙСТВА НА ОС ANDROID

**В вашем телефоне Android**

* Откройте настройки
* Включите режим разработчика
* Зайдите в настройки разработчика
* Включите опцию **Enable Bluetooth HCI snoop log \(**Включить журнал Bluetooth HCI**\)**
* Выполните манипуляции, которые необходимо отследить
* Выключите опцию **Enable Bluetooth HCI snoop log \(**Включить журнал Bluetooth HCI**\)**
* Скопируйте файл с логами на ПК через ADB \(Android Debug Bridge\)
* Необходимый файл называется **btsnoop\_hci.log**

Примечание: Обычно я оставляю опцию **Enable Bluetooth HCI snoop log** включенной, поскольку использую тестовый телефон с правами пользователя root.

### **Получение btsnoop\_hci.log о сеансе Bluetooth**

**Файлы Android**

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image13-2.png)

**Записанные файлы btsnoop\_hci log** 

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image14.png)

**Переименуем btsnoop\_hci.log в btsnoop\_hci-07-31-20.log**

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image3-4.png)

## Анализ при помощи Wireshark

Открыв btsnoop\_hci.log в Wireshark, мы можем увидеть обмен пакетами, зашифрованными OTA. Совмещая изучение файла в Wireshark с функцией hexdumps ПО Frida мы можем изучить работу пользовательского сеанса. Из огромного количества сеансов, сгенерированных во время моего исследования замка KeyWe, стало ясно, что обмен пакетами происходит в одной и той же последовательности в каждом сеансе. В следующем примере мы можем увидеть обмен ключами, инициированный приложением, за которым следует открытие замка.

**Пример 1:  Приложение отправляет AppNumber  — замок возвращает DoorNumber  —  замок отправляет Hello**

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image16.png)

**Примечание:** \(на скриншоте выше\): **fb2b28c68b3f99c514b98fada4bf0b89** \(передача №2\) расшифровывается с помощью **CommonKey** для воспроизведения **DoorNumber**!

Это можно проверить с помощью бесплатного инструмента дешифровки AES-128 здесь:: [http://aes.online-domain-tools.com/](http://aes.online-domain-tools.com/)

Введите зашифрованный пакет **fb2b28c68b3f99c514b98fada4bf0b89** и секретный ключ \(CommonKey\) **c88ff4150f4a4c27934a6c5e6741efac**, затем нажмите «Расшифровать».

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image8-2.png)

Использование онлайн-инструмента AES-128 Cipher - один из удобнейших способов сопоставления данных из Wireshark с данными из Frida. На следующих скриншотах показаны примеры того, как различный трафик Bluetooth OTA совпадает с известными вызовами функций приложения. Из этого можно извлечь много информации о работе программы.

**Пример 2:** **Приложение отправляет Welcome**  **—**  **замок отправляет START  —  приложение и замок обмениваются doorMode**

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image17.png)

**Пример 3:** **Приложение отправляет eKey  —**  **замок отправляет eKey** **\(аутентификация и авторизация\)** 

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image5-3.png)

**Пример 4: Получение статуса замка— обмен doorTimeSet** 

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image6-2.png)

**Пример 5: Получение статуса замка**

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image26-2.png)

## **Атака повторного воспроизведения**

Как видно из скриншотов \(выше\), весь сеанс передачи данных можно проанализировать в Wireshark и сравнить с данными, полученными с помощью Frida. Также обратите внимание, что каждый из зашифрованных пакетов \(OTA\), можно расшифровать, просто определив направление передачи \(от приложения к замку или от замка к приложению\), используя соответствующий ключ \(**AppKey** или **DoorKey**\) для их расшифровки.

Теперь у нас есть ключи, мы знаем, как интерпретировать данные и можем задействовать блокировку с помощью атаки методом повторного воспроизведения пакетов. F-Secure выложили в своем Github инструмент, который они назвали «open\_from\_pcap». Основываясь на информации записанной в их pcap, этот инструмент позволил им воспроизвести сеанс и получить контроль над замком. Конечно, этот инструмент перестал быть вредоносным, после того, как они УДАЛИЛИ свой скрипт keys.py. Однако, в результате данного исследования функции удаленного скрипта удалось восстановить. Заменив keys.py F-Secure своей версией этого скрипта, я смог использовать инструмент «open\_from\_pcap».

Я использовал USB-адаптер Bluetooth Sena UD100 и первый результат выполнения программы open\_from\_pcap показан на скриншоте ниже:

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image9-2.png)

Мой скрипт keys.py правильно определил **CommonKey**, **AppKey** и **DoorKey**, но не смог провести верификацию ключа \(eKeyVerify\).

Если не углубляться в код F-Secure, программа open\_from\_pcap вызывает функцию из другого скрипта \(decode\_from\_pcap\), которая предположительно извлекает eKey из pcap файла записанного во время сеанса передачи данных. К сожалению, у меня это не получилось. Возможно, это было связано с разницей в структуре их файла pcap и моего файла btsnoop\_hci.log \(сохраненного как pcap из Wireshark\). Тем не менее, я решил отказаться от чтения их кода и вместо этого записал eKey непосредственно в программу open\_from\_pcap, заменив этим процесс его получения.

Причина, по которой сотрудникам F-Secure требовалось получать ключ из pcap файла, заключается в том, что eKey хранится в сети при создании учетной записи и не присутствует в OTA трафике. Однако, его можно обнаружить с помощью Frida, вызвав функцию eKeyVerify, которая предоставляет шестнадцатеричный дамп.

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image11-2.png)

Как вы можете видеть на скриншоте выше, я удалил свою учетную запись KeyWe и создал новую, для того, что узнать, какие изменения происходят при переходе от одной учетной записи пользователя к другой, и может ли eKey быть предсказуемым. Насколько я могу судить, очевидных закономерностей нет. EKey \(также известный как пароль пользователя\) генерируется, когда владелец создает учетную запись, поэтому ключ может быть полностью случайным, но и может быть получен из пароля пользователя во время настройки учетной записи. Поэтому, когда я создавал новую учетную запись, я намеренно изменил только один символ в исходном пароле. Я хотел определить, был ли eKey получен исключительно из пароля пользователя. На мой взгляд, это не так.

Из приведенного выше снимка экрана очевидно, что функция eKeyVerify была вызвана приложением, а переданный аргумент был 6-байтовым значением \(eKey\). Можно предположить, что возвращаемое значение является измененным eKey, который отправляется приложением \(и зашифровывается с помощью AppKey\) замка. Не углубляясь в код, я могу только предположить, что 6-байтовое значение \(eKey\) предоставляет ссылку на фактический eKey. Тем не менее, этот 6-байтовый eKey - это все, что требуется для сеанса воспроизведения.

Запись eKey в скрипт replay.py привела к следующему результату:

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image10-2.png)

**Успех!!** [**https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/replay-1-1-1-1.mp4**](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/replay-1-1-1-1.mp4)\*\*\*\*

Атака прошла успешно, так как я смог получить eKey \(используемый для аутентификации и авторизации\), путем его извлечения из своего телефона \(с доступом к учетной записи пользователя root\) с помощью Frida. Такая атака методом повторного воспроизведения не будет работать в реальных условиях из-за того, что eKey законного владельца недоступен, так как не передается по OTA.

Но утверждение выше оказалось частично неверным! 

Рассмотрим следующий фрагмент, записанный в btsboop\_hci.log и соответствующий шестнадцатеричный дамп функции eKeyVerify:

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image2-4.png)

Wireshark показывает начало передачи пакетов \(обмен ключами, рукопожатия и т. д.\). Обратите внимание на 8-й пакет в этом сеансе. Он показывает зашифрованный пакет, отправленный приложением, содержащий измененное значение eKey. Обратите внимание, что в дампе Frida что 6-байтовое значение eKey содержится в байтах \(5:11\) измененного значения eKey.

Основываясь на данных, полученных нами ранее, этот пакет шифруется перед передачей AES-128, используя **AppKey** в качестве секретного ключа.

Используя онлайн-инструмент AES-128 Cipher для дешифровки 8-го зашифрованного пакета OTA: **46402315a85a72e66e9671d044b513af** и AppKey: **e022c1193ebb3882efc9cf79b6e557d1** в качестве секретного ключа, мы получили расшифрованный и модифицированный eKey. Как мы знаем, 6-байтовое значение eKey содержится в байтах \(5:11\) расшифрованного модифицированного значения eKey. \(Ниже\)

![](https://www.blackhillsinfosec.com/wp-content/uploads/2020/08/image21.png)

Этот опыт наглядно показывает, что перехват OTA трафика в реальных условиях - возможен и может дать все необходимое \(включая пароль пользователя - eKey\), для чтобы поставить под угрозу домашнюю безопасность и открыть замок!

## **Вывод**

Я должен признать, что я потратил огромное количество времени на свои исследования \(порядка нескольких месяцев\), в основном из-за того, что имел дело с обфускацией кода, но также из-за обучения, связанного с появлением новых программ в моем арсенале. Кроме того, было не менее полезно разобрать приложение Android, понимая, что прошло больше года с момента выпуска рекомендаций F-Secure и у поставщика была возможность для исправления ошибки безопасности. Я полностью согласен с выводами исследователей F-Secure, в том, что возможность обновления прошивки, безусловно, помогла бы в исправлении этой уязвимости, и что использование пользовательских криптоалгоритмов не является хорошей идеей.

Я завершаю эту статью, но мне еще нужно разобраться с некоторыми незавершенными исследованиями, которые представляют собой захват OTA сеанса между моим личным телефоном без рута и замком KeyWe, чтобы провести атаку методом повтора сигнала, которая БУДЕТ работать в реальных условиях. Тем не менее, чтобы уменьшить воздействие подобных атак, я настоятельно рекомендую текущим владельцам замков Guardtec KeyWe как можно скорее обновить свое мобильное приложение до последней версии \(2.1.0 на момент написания этой статьи\).

