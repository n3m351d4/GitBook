---
description: '2020-05-08'
---

# SDR: Бинарные SMS-сообщения

Перевод: @ZzzNein (благодарность можно выразить [ЗДЕСЬ](https://yasobe.ru/na/na\_perevody\_i\_kontent))

__[_Источник_](https://www.contextis.com/us/blog/binary-sms-the-old-backdoor-to-your-new-thing)

Несмотря на то, что сама система старше многих пользователей, служба коротких сообщений (SMS) остается крайне популярным способом общения и все чаще используется для дистанционных приборов обнаружения, на объектах жизнеобеспечения населения и транспортных средствах ввиду доступности сотовой связи. Для простых пользователей мобильных устройств SMS – это всего лишь стандартное символьное сообщение в 160 знаков. Для операторов и разработчиков это гораздо более мощный инструмент с множеством опций и бинарных полезных нагрузок, подробно описанных в спецификации GSM 03.40. В теории, максимальный размер сообщения может достигать 35 кб.

Операторы связи используют эти расширенные функции для удаленного управления. SMS-сообщения служат для дистанционной отправки команд для запуска и взаимодействия со скрытыми приложениями на устройствах без согласия пользователя. Правоохранительные органы могут отслеживать мобильные устройства с помощью «тихих» SMS-сообщений. Пользователю просто не приходит уведомление о таком SMS. Технология SMS лежит в основе многих платформ управления мобильными устройствами (MDM).

![](https://dc7495.org/aybbtu/uploads/2020/05/c-users-administrator-desktop-pdu\_exploitation\_q6.jpeg)

Связь между программным обеспечением смартфона и его радиоинтерфейсом намного больше, чем вы можете подумать. SMS-сообщения с вредоносными данными внутри могут внедряться в приложения для прослушивания контента и уже оттуда обрабатываться целевым программным обеспечением. Если ПО написано плохо, возможно удаленное повреждение памяти и выполнение произвольного кода. Средством передачи полезной нагрузки целевому приложению на вашем телефоне (или смартфоне) может служить PDU – модуль данных протокола. Он содержит фреймы пользовательских данных, которые без проверки перенаправляются на логический порт операционной системы со всеми привилегиями радиоинтерфейса (система работает в нормальном режиме). Представьте компьютер, на котором без брандмауэра запущены общедоступные сервисы.

## **Правовые вопросы и опции**

GSM-спектр – это крайне дорогая частная собственность. Вы не можете передавать (или даже получать) данные в GSM-диапазонах без разрешения. В Соединенном Королевстве, например, Законом о беспроводной телефонной связи несанкционированная передача в лицензируемом диапазоне частот запрещена. Кроме того, преступлением также является перехват GSM без ордера (Закон о правовом регулировании следственных полномочий). Перед запуском тестирования GSM сначала следует подать заявку на лицензию (ниже показан вариант такой лицензии Управления по делам радио, телевидения и предприятий связи – OFCOM). Помимо прочего, вам понадобится клетка Фарадея, чтобы подавить излучение. Именно поэтому исследование GSM-интерфейсов распространено куда менее, чем, к примеру, – работы по TCP/IP.

Если вы хотите заняться изучением OpenBTS, рекомендуем не публиковать скриншоты, которые предполагают, что вы нарушили закон. Это очень безответственно и может поставить под угрозу репутацию вашей компании.

![](https://dc7495.org/aybbtu/uploads/2020/05/https-www-contextis-com-media-images-made-media-.jpeg)

Если вы пользователь с ограниченным бюджетом, вы можете отправлять SMS в формате PDU как обычный абонент через существующего публичного оператора связи с помощью GSM-модема. Однако, сначала следует тщательно ознакомиться с его условиями. К примеру, согласно Условиям и положениям Vodafone, клиентам нельзя использовать сервис для нарушения закона или применять автоматизированные средства отправки текстовых сообщений. Создание скриптов для атаки телефона другого абонента запрещено по определению, но вы можете отправить одно-два SMS в формате PDU для тестирования собственного устройства. Так что решение полностью за вами.

## **Режим отправки SMS в формате PDU**

Для SMS определено всего два режима: текстовый и PDU. В режиме PDU можно определить весь фрейм. Это открывает огромную поверхность атаки из-за контролируемых пользователем полей, а также ввиду возможности получения вредоносного контента целевым приложением на телефоне. Красота режима PDU в том, что можно удаленно управлять плохо написанным мобильным приложением. А помогает этого добиться PDU-модуль данных протокола (PDU), позволяющий разбивать большие сообщения на сочлененные SMS-сообщения (C-SMS). И, что важно с точки зрения безопасности, отправлять сообщения, предназначенные для различных приложений, можно используя номера портов, схожие с TCP/IP.

WAP push – популярный пример двоичного PDU. Типичное push-сообщение WAP push вашего оператора может содержать настройки конфигурации GPRS или MMS, и после сборки появляется специальное сообщение, запрашивающее разрешение пользователя на обновление значений сетевой конфигурации из BLOB-объекта XML. WAP – довольно устаревший протокол, но это мощный инструмент, который можно успешно применять во вредоносных целях.

Вывод текстового сообщения на экран опционально. Некоторые SMS-сообщения поступают на ваши устройства без уведомления и никогда не отобразятся во входящих («тихое» SMS). Можно настроить принудительный вывод, установив тип «Class 0» (СМС с немедленным выведением на экран устройства абонента). Такую публичную систему оповещения в США используют экстренные службы. Сообщения приходят через эстафетную рассылку массовых сообщений по сотам. В этом случае все подключенные к вышке абоненты получают SMS одновременно.

## **Варианты среды тестирования SMS**

Тестирование SMS в режиме PDU можно проводить в собственной среде, обладая лицензией на тестирование GSM, или через общедоступного оператора. У частной среды тестирования есть несколько ключевых преимуществ:

* Стоимость – отправка большого количества SMS-сообщений может обходиться дорого, особенно когда вы начинаете их объединять.
* Управление – у популярного оператора SMS-сообщения могут отправляться с непредсказуемой задержкой и быть подвержены ограничениям
* Отладка – частная среда позволяет отслеживать сообщения и отклики по эфирному интерфейсу, что чрезвычайно важно на раннем этапе тестирования.

Публичный оператор связи (потенциально) обойдется гораздо дешевле. Это более быстрое решение, нужен всего лишь «свисток» 3G. Но, используя данное решение, вы жертвуете управлением и должны соблюдать условия и положения оператора, которые могут запрещать тестирование в этой сети.

### **Частная среда тестирования SMS**

Для изучения SMS в формате PDU с помощью эфирного интерфейса необходима базовая станция GSM. OpenBTS – самое известное свободное программное обеспечение – программная [точка доступа ](https://ru.wikipedia.org/wiki/%D0%A2%D0%BE%D1%87%D0%BA%D0%B0\_%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0) стандарта [GSM ](https://ru.wikipedia.org/wiki/GSM), позволяющая совершать звонки с [мобильных телефонов ](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B1%D0%B8%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9\_%D1%82%D0%B5%D0%BB%D0%B5%D1%84%D0%BE%D0%BD) без использования сетей существующих поставщиков телекоммуникационных услуг (сотовых операторов). Существует множество гайдов по настройке OpenBTS для различных платформ. По нашему опыту OpenBTS действительно быстро и легко настраивается, но работа именно с PDU требует массы усилий. Интерфейс командной строки (CLI) отвечает за отправку SMS обоих типов, но алгоритм валидации PDU для входящих SMS-сообщений слишком забагован. А нас интересует прежде всего именно этот механизм. Потратив значительное время на решение проблемы с валидацией (и, судя по комментариям разработчика и блокам try/catch, мы были такие не одни), мы наткнулись на программу YateBTS. И она куда лучше подходит для тестирования входящих SMS.

YateBTS можно установить на Raspberry Pi 3, что само по себе является преимуществом. Простая портативная форма позволяет поместить устройство внутри клетки Фарадея так, чтобы к нему могло обращаться сразу множество пользователей по локальной сети. Расстояние между радиоточкой и хост-машиной должно быть как можно меньше. Также не следует увлекаться гирляндной сборкой кабелей USB, поскольку требования синхронизации настолько высоки, что в этом случае у вас будут проблемы со стабильностью.

![](https://dc7495.org/aybbtu/uploads/2020/05/https-www-contextis-com-media-images-made-media-1-1.jpeg)

#### **СПИСОК ОБОРУДОВАНИЯ**

Все цены указаны приблизительно. Вместо клетки Фарадея можно использовать подвал или комнату с двойными бетонными стенами, но при этом лицензирующий орган должен считать достаточным подавление излучений (>60дБ). Коэффициент затухания двенадцатидюймовых бетонных блоков равен 35дБ при 900мГц.

Ettus USRP B200 с антеннами 2 900мГц: 600 фунтов\
Ettus GPSDO (TCXO) с GPS-антенной: 500 фунтов\
Ramsey STE3000 корпус RF: 1500 фунтов\
Raspberry Pi 3: 35 фунтов\
YateBTS: бесплатно\
Wireshark: бесплатно\
Драйвер Osmo-trx: бесплатно\
Библиотека Ettus UHD: бесплатно\
**Итого: 2635 фунтов **_**(240 849 рублей, ред.)**_

#### **СБОРКА**

Открытые гайды по BTS устаревают быстрее, чем ядро Gentoo. Это происходит из-за того, что мир бесплатного GSM развивается невероятно быстро и требует оперативных решений. Мы рекомендуем сосредоточиться на изучении стандарта и основных требований, а не отдельных комплектов. Тем не менее, если вы хотите получить наиболее актуальное руководство, вы найдете исчерпывающий гайд по BTS (Yate) на Raspberry Pi по ссылке: [https://www.evilsocket.net/2016/03/31/how-to-build-your-own-rogue-gsm-bts-for-fun-and-profit/](https://www.evilsocket.net/2016/03/31/how-to-build-your-own-rogue-gsm-bts-for-fun-and-profit/)

OpenBTS и YateBTS не предписывают использование конкретных аппаратных средств или драйверов. Следовательно, они подходят для применения с несколькими радиоточками, при условии, что они поддерживают точные требования синхронизации базовой станции GSM (коэффициент погрешности – 0.05 ppm). Для пикосот они ниже – 0.1 ppm.

Если вы попробуете собрать BTS без источника прецизионного тактового сигнала, он будет нестабилен. Если повезет, ваше устройство увидит сеть и сможет ненадолго к ней подключиться, но сборка рухнет, как только вы запустите тестирование. Источник прецизионного тактового сигнала – существенный компонент.

Для нашего варианта устройства GPS нужна внешняя приемная GPS-антенна. Для получения фиксированного значения (зеленый светодиод) изначально нужно некоторое время.

Ключевое изменение конфигурации для использования ПК с низким энергопотреблением (Raspberry Pi) – сторонний радиодрайвер, который определяется в ../etc/yate/ybts.conf. Мы успешно задействовали официальный драйвер Ettus UHD, но предпочли совместимый с ARM приемопередатчик osmo-trx, скомпилированный с UHD 003.010 и определенный как Path=./osmo-trx, расположенный по адресу ../lib/yate/server/bts/osmo-trx

#### **ТЕСТИРОВАНИЕ**

Для проведения тестирования SMS вам не обязательно понимать все уникальные аспекты радиоинтерфейса GSM, но понимание принципа передачи сигнала системы поискового вызова определенно не помешает. Добиться подключения устройства к сети – уже пол дела, дальше все довольно просто и относится скорее к вычислениям, нежели к работе с радиочастотами.

Вывод PCAP-файлов gsmtap на емкостный сенсорный экран – бесценный инструмент проверки ваших настроек и отслеживания трафика по радиоинтерфейсу. Чтобы его использовать, войдите в веб-интерфейс Yate и поменяйте IP-адрес на свой, установите флажок gsmtap, а затем запустите на внешнем интерфейсе Wireshark. Эту функцию можно инициировать удаленно, что удобно для пользователей внутри локальной сети. UDP-пакеты gsmtap для каналов восходящей и нисходящей связи будут вслепую отправляться на порт 4729 хоста и, вероятно, спровоцируют закрытые ответы порта ICMP.

Исправный BTS будет постоянно передавать пакеты данных по каналу радиовещания (BCCH) и абоненты смогут подключаться к нему, указав свой международный идентификатор мобильного абонента (IMSI), если это позволяют правила доступа. Первое, что делает BTS после отправки SMS – отслеживает телефон по общему каналу управления (CCCH) и поверяет на присутствие. После получения ответа от устройства BTS отправляет SMS в формате PDU по отдельному выделенному каналу управления (SDCCH).

На скриншоте ниже показана отправка «склеенного» SMS-сообщения из 3 частей от абонента 12345 с помощью нашего YateBTS. Сборка происходит только после получения последнего фрагмента. Каждый фрагмент распознается отдельно, что полезно для решения проблем конкатенации.

![](https://dc7495.org/aybbtu/uploads/2020/05/https-www-contextis-com-media-images-made-media-1-2.jpeg)

#### **ФИЛЬТРЫ WIRESHARK**

* Только GSM: gsmtap && !icmp
* Только пейджинговая активность: gsmtap.chan\_type == CCCH && !icmp
* Только SMS (восходящая/нисходящая связь): gsm\_a.dtap.msg\_sms\_type == 0x01
* Только SMS от абонента 12345: gsm\_sms.tp-oa == “12345”
* Только SMS ack от абонента: gsm\_a.rp.msg\_type == 0x02

Чтобы отправить сообщение в режиме PDU через YateBTS вы можете воспользоваться специальным скриптом веб-интерфейса по адресу /nib\_web/custom\_sms.php или же более гибким интерфейсом telnet на порту TCP 5038. Оба способа требуют IMSI получателя, которого можно найти в списке зарегистрированных абонентов или путем отслеживания регистрации телефона и передачи сигнала системы поискового вызова по радиоинтерфейсу. Мы упаковали интерфейс telnet в собственный PHP-скрипт, используя API сокетов:

```
// PHP
 
$cmd="control custom_sms called=$imsi $type=rpdu";
$socket = fsockopen("localhost", "5038", $errno, $errstr); 
fputs($socket, "$cmd")
```

С помощью нашего веб-API для SMS мы не только смогли дать другим исследователям по локальной сети доступ к рассылке в режиме PDU, но и ослабить требования к объему знаний для SMS-тестирования.

Сообщение в формате PDU, отправленное по радиоинтерфейсу выглядит иначе, чем такое же, переданное по общедоступной сети, ввиду различий форматов SMS-DELIVER (BTS > MS) and SMS-SUBMIT (MS > BTS). См. раздел PDU-модуль данных протокола (PDU).

### **Общедоступная среда тестирования SMS**

Тестирование в режиме PDU не должно быть затратным. Вы можете отправлять уникальные сообщение в режиме PDU, используя любое GSM-устройство, позволяющее отправлять команды AT-модема. Практическое решение – элементарный 3G-свисток, например – Huawei E3533, или даже стандартная макетная плата Adafruit серии FONA.

![](https://dc7495.org/aybbtu/uploads/2020/05/https-www-contextis-com-media-images-made-media-1-3.jpeg)

Используя в качестве примера Huawei E3533 стоимостью 20 фунтов, следует убедиться, что устройство подключено в режиме GSM-модема (не адаптера Ethernet, съемного накопителя и т.д.). На Linux за это отвечает команда usb\_modeswitch:

```
usb_modeswitch -v 0x12d1 -p 0x1f01 -V 0x12d1 -P 0x14db -M
 
"55534243123456780000000000000011063000000100010000000000000000"
```

Команды для конкретных устройств можно найти на форуме: [http://www.draisberghof.de/usb\_modeswitch/bb/ ](http://www.draisberghof.de/usb\_modeswitch/bb/)

Получив /dev/ttyUSBx, подключитесь к нему через последовательную консоль (например, minicom) и введите следующие команды Hayes AT: AT+CMGF=0 – чтобы перевести модем в режим PDU; AT+CMGS=n – чтобы подготовиться к отправке PDU длиной n байт, а затем – собственно само сообщение PDU в шестнадцатеричном формате.

Для получения информации о длине, возьмите общее количество шестнадцатеричных символов, разделите его на 2 для получения байтов, а затем отнимите 8 байт, чтобы узнать номер получателя.

**Совет: Для отправки PDU используйте сочетание Ctrl-Z. НЕ нажимайте Enter.**

Последовательные команды можно легко написать с помощью библиотеки pyserial. Прежде чем запускать интерпретатор Python, еще раз сверьтесь с условиями и положениями вашего оператора касательно автоматической отправки SMS-сообщений. Пока вы контролируете передачу каждого сообщения, все в порядке.

Вот пример базового клиента на Python для отправки сообщений в формате PDU через GSM-модем:

```
# Python
 
ser = serial.Serial(tty, 115200, timeout=5)
ser.write('AT')
if "OK" in ser.read(64): 
     print "CONNECTED TO MODEM OK" 
     ser.write("AT+CMGF=0") # PDU mode 
     ser.write("AT+CMGS=%d" % ((len(pdu)/2)-8)) 
     time.sleep(1) 
     ser.write('%s' % pdu) 
     print ser.read(64) 
else: 
     print "MODEM FAILURE"
ser.close()
```

## **PDU-модули данных протокола (PDU)**

В стандарте GSM 03.40 описаны блоки данных транспортного протокола (TPDU), которые используются для передачи SMS. TPDU задействованы в процессе прохождения сообщений по телекоммуникационной сети.

Существуют различные виды SMS PDU. Сообщения MO FSM (короткое сообщение от мобильного терминала) – SMS-SUBMIT, может начинаться с байта 0x01, а – SMS-DELIVER, может начинаться с байта 0x00; последнее обычно длиннее ввиду добавления 7-октетной метки времени цифровой сети (SCTS). Первый байт является битовой маской из нескольких флагов и содержит массу информации.

Кодирование PDU – довольно сложная задача, но, к счастью, существует множество онлайн-кодировщиков и программных библиотек (например, smspdu на Python для валидации PDU в стандарте GSM 03.40). Прежде чем перейти непосредственно к практике, важно изучить некоторые ключевые моменты и существенную разницу между типами DELIVER и SUBMIT, поскольку многие онлайн-кодировщики работают только с сообщениями SUBMIT и отсекают DELIVER. Мы протестировали множество программных средств и можем порекомендовать библиотеку smspdu на Python.

Пример валидации PDU:

**python -m smspdu \[PDU]**

В поле идентификатор протокола (PID) указывается применимый протокол прикладного уровня. Для простых коротких сообщений выставлено значение по умолчанию 0x00. Перевод значения PID в значение 0x64 позволит отправлять «тихие» SMS (SMS «типа 0»). Именно их телефоны могут принимать без уведомления пользователя. Как говорилось ранее, данный вариант используется правоохранительными органами для активного пинга устройства в сети.

#### **ЗАГОЛОВКИ ПОЛЬЗОВАТЕЛЬСКИХ ДАННЫХ И КОНКАТЕНАЦИЯ**

Если вы хотите атаковать приложение на телефоне, вам нужно определить порт-адресат в заголовке пользовательских данных (UDH), который расположен между заголовком PDU и пользовательскими данными (UD) и объявляется на раннем этапе через флаг индикатора в заголовке пользовательских данных (UDHI) в первом октете.

Именно в UDH содержится описание фрагментов C-SMS.

Технология SMS позволяет аккумулировать и отправлять как отдельные сообщения большие (двоичные) пакеты данных, причем не обязательно сохраняя последовательность. Таким образом можно переправлять приложению до 35,700 байт пользовательских данных в виде 255 текстовых сообщений (Предупреждение: оплата будет считаться за каждое SMS!!!).

Чтобы собрать большое сообщение, нужно сначала разбить его на фрагменты пользовательских данных не более 140 октетов каждое. Суммарный фрагмент маркируется флагом UDHI в первом байте, указывая на то, что первые несколько байтов UD являются фрагментарной информацией, которая в дальнейшем поможет пересобрать кусочки по порядку.

В начале каждого отправленного фрагмента будут стоять байты заголовка SMSC, номера адресата, PID и данных схемы кодирования (DCS).

Заголовок фрагмента содержит счетчик фрагментов, уникальный байт, служащий идентификатором пакета для всех фрагментов, и данные об общем числе таковых.

Пример UDH, устанавливающего адресацию на 16-битный порт **И** конкатенацию:

0A050B8457320003FF0201

**0A:** Длина UDH минус полу длины: 10

**05:** Адресация на 16-битный порт приложения (следующие четыре октета)

**0B84:** Порт-адресат: 2948 (WAP push)

**5732:** Порт-источник: 1664

**00:** C-SMS

**03**: Длина элемента информации для секции C-SMS: 3

**FF:** Уникальный идентификатор сообщения: 255

**02:** Итого фрагментов: 2

**01:** Данный фрагмент: 1

Другие опции UDH описаны в стандарте 3GPP 23.040.

**Hello World! SMS-SUBMIT PDU**

Для следующего PDU, отправленного на номер мобильного абонента цифровой сети с интеграцией служб (MSISDN) +441234567890, выставлен флаг «немедленный вывод». Следовательно, сообщение сразу появится на экране телефона (flash SMS):

**01000C9144214365870900000CC8329BFD065DDF72363904**

Стоит помнить, что кодирование данных в разных разделах отличается. Некоторых из них представляют собой специальные битовые маски, другие – зашифрованы 7-битным GSM-кодированием, третьи – простые шестнадцатеричные.

![https://www.contextis.com/media/images/made/media/images/content/helloworld.width-800\_794\_436\_75.jpg](https://dc7495.org/aybbtu/uploads/2020/05/https-www-contextis-com-media-images-made-media-1-4.jpeg)

**01:** SMS-SUBMIT with default flags (битовая маска)

**00:** Сообщение «типа 0» (биты 0-1), установлен флаг отклонения дубликатов (бит 2) (битовая маска)

**0C:** Длина приема 12 цифр (0x0C)

**91:** Международный номер ISDN (Схемы присвоения номеров абонентам) (битовая маска)

**442143658709:** MSISDN адресата (+441234567890) (7-битное GSM-кодирование)

**0000:** Идентификатор протокола 0: стандартное SMS-сообщение, Схема кодирования данных 0: Флэш-сообщение (битовая маска)

**CC8329BFD065DDF72363904:** Пользовательские данные: Hello World! (7-битное GSM-кодирование)

#### **GSM-ИНТЕРФЕЙСЫ ТЕЛЕФОНОВ НЕ ОБЛАДАЮТ межсетевОЙ защитОЙ**

Если взять телефон на базе Android, то при получении SMS в формате PDU в журнале можно проследить следующую активность. Радиоинтерфейс (RIL) уведомляет ядро о входящем **нежелательном** PDU длиной 168 символов (21 байт). Полный PDU пишется в базу данных SQLITE, далее в есть направляется ответное автоматическое подтверждение (SMS-DELIVER-ACK), и, наконец, PDU доставляется **привилегированному** получателю SMS на Android для дальнейшей обработки. В данном случае оно попадает в банк сообщений, хотя его можно перенаправить в приложение для прослушивания контента, если в UDH задан порт-адресат.

Единственная проверка происходит в SmsHandler(). Проверяется только разрешение на прием SMS-сообщений. Никакой проверки пакетов или фильтров портов подобной фаерволам в IP – нет.

```
adb logcat -b radio I/RILC 
( 2139): RIL_SOCKET_1 
  UNSOLICITED: UNSOL_RESPONSE_NEW_SMS 
  length:168D/RILJ 
( 2988): [UNSL]< UNSOL_RESPONSE_NEW_SMS [SUB0]D/GsmInboundSmsHandler
( 2988): IdleState.processMessage:1D/GsmInboundSmsHandler
( 2988): Idle state processing message type 1D/GsmInboundSmsHandler
( 2988): acquired wakelock, leaving Idle stateD/GsmInboundSmsHandler
( 2988): entering Delivering stateD/GsmInboundSmsHandler
( 2988): DeliveringState.processMessage:1D/GsmInboundSmsHandler
( 2988): isSMSBlocked=falseD/GsmInboundSmsHandler
( 2988): URI of new row -> content://raw/1D/RILJ 
( 2988): [9382]> SMS_ACKNOWLEDGE true 0 [SUB0]D/GsmInboundSmsHandler
( 2988): DeliveringState.processMessage:2D/RILC 
( 2139): SOCKET RIL_SOCKET_1 
     REQUEST: SMS_ACKNOWLEDGE 
     length:20D/GsmInboundSmsHandler
( 2988): Delivering SMS to: com.android.mms com.android.mms.transaction.PrivilegedSmsReceiver
```

### **Отправление произвольных данных на порт 2948**

В данном примере SMS-SUBMIT, содержащее испорченный WBXML в 1000 символов, было разбито на 7 фрагментов и отправлено на приложение WAP-push, прослушивающее порт 2948. Ввиду номера порта делается предположение о типе данных, которые содержит пакет (WBXML). Это могут быть любые двоичные данные, адресованные любому порту.

Байты PDU:\
**41000C9144214365870900009B0B05040B8457320003FF0201C2E170381C0E87C3E1703**

**81C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E1703**

**81C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E1703**

**81C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E1703**

**81C0E87C3E17018**

![https://www.contextis.com/media/images/made/media/images/content/badpdu.width-800\_800\_548\_75.jpg](https://dc7495.org/aybbtu/uploads/2020/05/https-www-contextis-com-media-images-made-media-1-5.jpeg)

**41:** SMS-SUBMIT с UDH (битовая маска), установлен флаг отклонения дубликатов (bit 2), установлен флаг UDH (бит 3)

**00:** Сообщение «типа 0» (биты 0-1) немедленный вывод на экран

**0C:** Длина приема 12 цифр (0x0C)

**91:** Международный ISDN (Схемы присвоения номеров абонентам) (битовая маска)

**442143658709:** MSISDN адресата (+441234567890 в 7-битной кодировке ASCII)

**0000:** PID: 0, DCS: 0

9B: Длина пользовательских данных (включая UDH): 155

**0B05040B8457320003FF0201:** UDH.

Длина: 0x0B

Адресация на 16-битный порт: 0x05

Длина – четыре октета: 0x04

Порт-адресат: 0x0B84

Порт-источник: 0x5732

C-SMS: 0x00

Длина – три октета: 0x03

Идентификатор последовательности: 0xFF

Итого фрагментов: 0x02

Данный фрагмент: 0x01

**C2E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E1703**

**81C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E170381C0E87C3E1703**

**81C0E87C3E170381C0E87C3E17018:** Пользовательские данные. Испорченный WBXML, состоящий из повторяющейся последовательности буквы «а».

## **Заключение**

SMS – слабое звено безопасности телефона. С помощью SMS вы можете удаленно взаимодействовать с приложениями на чужом телефоне, даже когда устройство не подключено к Интернету. Что примечательно, нет никакого фаервола, поэтому вредоносные пакеты ВСЕГДА достигают цели.

Несмотря на почтенный возраст технологии, она куда менее изучена, чем протокол Internet. Многие приложения (а теперь и нестандартные устройства) принимают SMS в формате PDU и доверяют таким пакетам больше, чем приходящим по IP.
