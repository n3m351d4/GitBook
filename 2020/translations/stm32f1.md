# Исключительный провал – Взлом защиты от чтения STM32F1

Прошивка микроконтроллеров зачастую содержит ценные данные, такие как интеллектуальная собственность, а иногда и ключи шифрования \(криптографические материалы\). Для их защиты в большинстве микроконтроллеров используют механизмы защиты от чтения. Задача такого механизма – ограничить чтение данных из внутренней флэш памяти злоумышленником, обладающим физическим доступом к устройству. Однако, как исследователи безопасности, так и любители, регулярно показывают, что эти механизмы можно обойти. В данном исследовании мы рассмотрим защиту от чтения флеш памяти в семействе микроконтроллеров STM32F1 STMicroelectronics. Мы обсудим новую уязвимость, эксплуатация которой является первым неинвазивным способом обхода защиты. Причиной этой уязвимости является недостаточное ограничение доступа: чтение данных из флэш-памяти через отладочный интерфейс блокируется, но система прерываний ЦПУ имеет доступ к этим данным по шине ICode. Мы подробно рассмотрим почему и как эта уязвимость раскрывает значительную часть внутренней памяти, тем самым компрометируя устройство.

**\[**[**Видео**](https://blog.zapb.de//files/stm32f1-exceptional-failure/firmware_extraction_1080p.mp4)**\]**

## **Введение**

Для защиты интеллектуальной собственности и прочих ценных данных, таких как ключи шифрования, учетные данные и т.д. – защита внутренней памяти становится задачей первостепенной важности. В том случае, если атакующий получает доступ к прошивке, он может клонировать устройство, изменить его функционал или извлечь учётные данные. В связи с этим защита микроконтроллера играет серьезную роль в безопасности встраиваемых систем. Это касается не только устройств, требующих повышенный уровень защиты, но и коммерческих микроконтроллеров.

Отключение отладочного интерфейса является частым способом противодействия злоумышленникам, однако его реализация отличается у разных микроконтроллеров. К примеру в [семействе STM32F0](https://www.st.com/en/microcontrollers-microprocessors/stm32f0-series.html) этот интерфейс можно полностью отключить. В то же время, семейство STM32F1 такой возможностью не располагает, предлагая несколько альтернатив. Одной из них является защита флэш-памяти от чтения \(read-out protection, RDP\). Этот механизм блокирует доступ к любым данным во флэш-памяти через отладочный интерфейс. Это значит, что атакующий может подключить отладчик к микроконтроллеру, но прочитать из него данные он не сможет.  
****  
Однако исследования показали, что у некоторых микроконтроллеров этот механизм имеет изъяны. Например, в своем исследовании ["Shedding too much Light on a Microcontroller's Firmware Protection”](https://www.usenix.org/system/files/conference/woot17/woot17-paper-obermaier.pdf), ****Йоханнес Обермайер и Штефан Тачнер описали атаку на семейство STM32F0. Некоторые исследователи предположили, что эта уязвимость может также затрагивать другие семейства, такие как STM32F1. [Однако один из авторов это опроверг](https://www.mikrocontroller.net/topic/442881#5274755). До сего момента механизм защиты семейства STM32F1 считался безопасным, поскольку не было свидетельств, что его можно обойти. В этой статье мы рассматриваем уязвимость \([CVE-2020-8004](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8004)\), которая приводит к первой неинвазивной атаке на систему защиты флэш-памяти STM32F1**.**

## **Обнаружение уязвимости**

Семейство STM32F1 не предоставляет механизма перманентного отключения отладочного интерфейса. По этой причине атакующий с физическим доступом всегда имеет возможность получить контроль над ним. Однако встроенный механизм защиты от чтения пресекает любые запросы к данным при подключенном отладчике.  
Для того, чтобы изучить систему защиты мы использовали отладочную плату[ STM32 Nucleo-64](https://www.st.com/en/evaluation-tools/nucleo-f103rb.html) с установленным на ней микроконтроллером STM32F103RB. Защита от чтения на нём была включена и запрещала доступ к данным флэш-памяти по отладочному интерфейсу. Через интерфейс SWD этот микроконтроллер был подключён к отладчику SEGGER J-Link, как изображено на рисунке 1.

![&#x420;&#x438;&#x441;&#x443;&#x43D;&#x43E;&#x43A; 1. &#x41E;&#x442;&#x43B;&#x430;&#x434;&#x43E;&#x447;&#x43D;&#x430;&#x44F; &#x43F;&#x43B;&#x430;&#x442;&#x430; STM32 Nucleo-64 &#x438; &#x43F;&#x43E;&#x434;&#x43A;&#x43B;&#x44E;&#x447;&#x435;&#x43D;&#x43D;&#x44B;&#x439; &#x43A; &#x43D;&#x435;&#x439; &#x43E;&#x442;&#x43B;&#x430;&#x434;&#x447;&#x438;&#x43A; SEGGER J-Link](https://lh5.googleusercontent.com/WFspmRCT7mu7uxTdEO7c_fu43-pVNALx8DyhEjmVmvNviH_aOhsfemyA_VnYf-h5NJ3iNxh1cZ6mMSypCJRzX_FlJujqPa2gpkBT6IG_EmDDrKTrIDLR596raAPsiGFEFHV5hIc)

Мы начали наше исследовать с установки соединения с целевым микроконтроллером. Для этого мы запустили [OpenOCD ](http://openocd.org/)следующей командой:

`openocd -f interface/jlink.cfg -c "transport select swd" -f target/stm32f1x.cfg`

Затем мы открыли Telnet-сессию через OpenOCD, что дало контроль над микроконтроллером. Наконец, мы перезагрузили микроконтроллер командой перезагрузки с остановом, получив такой вывод:

`target halted due to debug-request, current mode: Thread`

`xPSR: 0x01000000 pc: 0x08000268 msp: 0x20005000`

На первый взгляд в нём нет ничего особенного. Однако, если внимательно прочитать вторую строчку, одно из значений должно вас заинтересовать: счетчик инструкций \(program counter, PC\) имеет значение 0x08000268, что является корректным адресом, расположенным во флэш-памяти. Это очень важно, поскольку перезагрузка является особым видом исключения. При обработки каждого исключения, в процессор загружается соответствующий адрес обрабатывающей функции из таблицы векторов в PC. Эта процедура иногда называется запросом вектора \(vector fetch\). После перезагрузки устройства, таблица векторов располагается во флэш-памяти. Это наблюдение показывает, что процессор получил вектор обработчика перезагрузки из флэш-памяти при условии того, что защита от считывания включена.  
Почему же процесс обработки исключений смог прочитать адрес? [Руководство к STM32F1](https://www.st.com/resource/en/reference_manual/cd00171190.pdf) даёт подсказку:

`ЦПУ Cortex®-M3 всегда получает значение вектора перезагрузки по шине ICode, что подразумевает, что загрузчик должен располагаться только в области кода (обычно, флэш-памяти).`

Запрос вектора перезагрузки происходит через шину ICode и таким образом обрабатывается как запрос инструкции, который разрешен несмотря на включенную защиту. По всей видимости, она следит только за обращениями к данным, что позволяет беспрепятственно запрашивать вектор перезагрузки по ICode. [Справочное руководство на Cortex-M3](http://infocenter.arm.com/help/topic/com.arm.doc.ddi0337e/DDI0337E_cortex_m3_r1p1_trm.pdf) предоставляет дополнительную информацию по запросам векторов:

`Запрос вектора производится либо по системной шине, либо по шине ICode в зависимости от местонахождения таблицы векторов [...]`

В конечном счёте, защита от чтения семейства STM32F1 не блокирует доступ к памяти по шине ICode. При возникновении исключения, соответствующий адрес, расположенный во внутренней памяти запрашивается по ICode, тем самым раскрывая содержимое памяти через PC.

## **Эксплуатация**

**Мы заметили, что при возникновении исключения запрос вектора раскрывает защищенные данные через PC. Далее мы рассмотрим, как такое поведение можно эксплуатировать для обхода системы защиты.**

**Мы уже упоминали таблицу векторов: она содержит инициализирующее значение главного указателя на стек \(main stack pointer, MSP\), за которым следуют указатели на обработчики всех исключений. Её содержимое, определённое архитектурой ARMv7-M, показано в Таблице 1. В ней содержатся исключения и их смещения относительно начала таблицы. Первые 16 исключений являются обязательными и определены архитектурой ARMv7-M. Остальные, так называемые "внешние прерывания", опциональны и зависят от устройства.**  


  


