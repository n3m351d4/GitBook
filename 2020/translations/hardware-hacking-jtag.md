# Hardware Hacking: JTAG – отладка микроконтроллера

_Перевела @ZzzNein \(безграничную благодарность можно выразить здесь - \), проверила @N3M351DA._ [_Оригинальный текст_](https://www.blackhillsinfosec.com/jtag-micro-controller-debugging/) _- Реймонд Фелч, 23 августа 2019 г._

## Введение

Почти всю жизнь проработав инженером-разработчиком прошивок встраиваемых систем, я довольно быстро заинтересовался реверс-инжинирингом с помощью JTAG. Данный текст поможет больше узнать об этом абстрактном и поэтому зачастую игнорируемом векторе атаки.

_Информация из https://ru.wikipedia.org/wiki/JTAG_

**JTAG** \(сокращение от англ. Joint Test Action Group; произносится «джей-тáг»\) — название рабочей группы по разработке стандарта IEEE 1149. Позднее это сокращение стало прочно ассоциироваться с разработанным этой группой специализированным аппаратным интерфейсом на базе стандарта IEEE 1149.1. Официальное название стандарта **Standard Test Access Port and Boundary-Scan Architecture**. Интерфейс предназначен для подключения сложных цифровых микросхем или устройств уровня печатной платы к стандартной аппаратуре тестирования и отладки.

На текущий момент интерфейс стал промышленным стандартом. Практически все сколько-нибудь сложные цифровые микросхемы оснащаются этим интерфейсом для:

·  выходного контроля микросхем при производстве

·  тестирования собранных печатных плат

·  прошивки микросхем с памятью

·  отладочных работ при проектировании аппаратуры и программного обеспечения

Метод тестирования, реализованный в стандарте, получил название Boundary Scan \(граничное сканирование\). Название отражает первоначальную идею процесса: в микросхеме выделяются функциональные блоки, входы которых можно отсоединить от остальной схемы, подать заданные комбинации сигналов и оценить состояние выходов каждого блока. Весь процесс производится специальными командами по интерфейсу JTAG, при этом никакого физического вмешательства не требуется. Разработан стандартный язык управления данным процессом — Boundary Scan Description Language \(BSDL\).

Стандарт предусматривает возможность подключения большого количества устройств \(микросхем\) через один физический порт \(разъем\).

Порт тестирования \(TAP — Test Access Port\) представляет собой четыре или пять выделенных выводов микросхемы: ТСК, TMS, TDI, TDO и \(опционально\) TRST.  
  
__**JTAG** – отладочный интерфейс, который стал промышленным стандартом для отладки и непрерывной диагностики интегральных схем после сборки печатной платы. Первоначально стандарт предлагал производителям упрощенный способ тестирования конструкции печатной платы. Сейчас он стал еще более актуален ввиду снабжения многих устройств технологией шариковых выводов \(BGA\), что затрудняет тестирование ввиду малых размеров. Кроме того, открытый интерфейс дает инженерам инструмент анализа сигналов без прямого взаимодействия с использованием физического подключения к схеме.

После просмотра множества видео о JTAG я обнаружил ряд положительных преимуществ при получении доступа целевому устройству, в особенности – возможность чтения и записи на эти устройства. Возможности казались безграничными. 

Чтобы начать работу, на местной распродаже я нашел маршрутизатор Linksys BEFSR41 версии 2. Именно его мне не хватало, чтобы начать экспериментировать с некоторыми из огромного количества аппаратных и программных инструментов JTAG. Я решил повторить достижения некоторых авторов тех видео, что просмотрел ранее.

Проведя более глубокие исследования, я решил приобрести плату JTAGulator фирмы Parallax и пару популярных плат с последовательным интерфейсом: DangerousPrototypes Bus Pirate, Bus Blaster и Attify Badge.

Сначала я работал с JTAGulator, аппаратным инструментом с открытым исходным кодом, разработанным Джо Грандом. Он может не только обнаруживать, но и идентифицировать контакты JTAG на целевой плате, что, в свою очередь, дает возможность находить интерфейсы отладки на кристалле \(OCD\). В этом инструменте также заложена возможность находить и идентифицировать контакты UART.

**Характеристики**

· 24 канала I/O с защитой на входе

· регулируемое целевое напряжение для преобразования уровня: 1.2В в 3.3В

· поддерживаемые интерфейсы \(начиная с версии прошивки 1.1.1.\): JTAG/IEEE, UART/асинхронный последовательный порт

· USB-интерфейс \(FTDI FT32\) для прямого соединения с хост-машиной \(ПК, Mac или \*nix\)

![JTAGulator ](../../.gitbook/assets/image%20%28214%29.png)

## **Обнаружение и идентификация контактов JTAG на целевой плате**

Перед тем, как начать, я нашел и распечатал техническое описание целевой платы – роутера Linksys BEFSR41 версии 2.

На плате я быстро обнаружил следующие **элементы**:

· ЦПУ: Samsung S3C4510001    ARM7TDI 50Мгц

· Флэш-ПЗУ:  MX 29F040QC-90    5 вольт CMOS \( 512 Кбит x 8 \) 0.5 МБайт

· SDRAM-память:  SI IC41C16256-35K x2 512 Кбайт – 256К x 16 DRAM

· Ethernet-контроллеры: полнодуплексный контроллер RealTek RTL8019AS ISA

· KENDIN KS8995E 5 портов 10/100 коммутатор в интегральном исполнении

На основании информации, полученной при просмотре обучающих видео о плате JTAGulator \(от автора Джо Гранда\), я нашел элемент, который мог оказаться JTAG TAP \(тестовой точкой доступа\) на JP-1.

Видео о JTAGulator от Джо Гранда: [https://www.youtube.com/watch?v=GgMOBhmEJXA](https://www.youtube.com/watch?v=GgMOBhmEJXA)

## **Определение контактов JTAG**

Часто на плате можно найти обозначения TMS, TCK, TDI, TDO и т.д., по которым можно сразу заключить, что вы имеете дело с устройством, поддерживающем JTAG. Трудности начинают возникать, когда контакты не помечены и приходится полагаться на стороннюю документацию. 

Конечно, может повезти, и на самой плате будет обозначение JTAG без указания контактов/пинов. Точки доступа JTAG зачастую специально скрыты разработчиками, и в большинстве случаев не имеют маркировки. Кроме того, можно заглянуть в техническое описание микроконтроллера. Иногда контакты помечаются JTAG-ориентирами, и дорожки на печатной плате приведут вас к точке доступа.

**Пример:**

![](../../.gitbook/assets/image%20%28211%29.png)

На моей целевой плате этот интерфейс представляет собой 2 ряда по 7 отверстий для разъёма JP-1. 

![](../../.gitbook/assets/image%20%28208%29.png)

И наконец, мне нужно было найти землю на целевом устройстве и подключить ее к контакту GND на плате JTAGulator. 

_ПРИМЕЧАНИЕ: Перед тем, как начинать любое тестирование, убедитесь, что JTAGulator и целевое устройство ОБЯЗАТЕЛЬНО обладают общей точкой заземления \(для обеспечения надлежащего опорного напряжения и верных показаний\)._

Кроме того, с помощью приспособления для демонтажа \(пневмоотсоса припоя\), я удалил припой с отверстий для разъема JP-1 и припаял \(2\) 7-контактные штыревые гребенки, чтобы облегчить подключение перемычек для отладки.

![](../../.gitbook/assets/image%20%28216%29.png)

Используя мультиметр, я определил, что все контакты 2, 4, 6, 8, 10, 12 и 14 привязаны к земле. После этого осталось еще 8 \(неопознанных\) контактов, 5 из которых могли оказаться 4 необходимыми \(и 1 опциональным\) контактами JTAG:

· TDI     Test data in – «вход тестовых данных»

· TDO    Test data out – «выход тестовых данных»

· TMS    Test mode select – «выбор режима тестирования»

· TCK     Test clock – «тестовое тактирование»

· TRST    Test reset \(optional\) – «тестовый сброс» \(опциональный\)

Используя каналы с 0 по 7 на плате JTAGulator, я соединил их перемычками с 8 \(неизвестными\) контактами на целевом устройстве \(порядок подключения не имел значения\).

_Примечание: контакт-14 – это зеленая перемычка \(GND\)._

![](../../.gitbook/assets/image%20%28218%29.png)

![](../../.gitbook/assets/image%20%28219%29.png)

На данном этапе я включил целевое устройство \(используя входящий в комплект адаптер постоянного тока на 9В\), а затем подключил плату JTAGulator к рабочему столу Linux через mini-USB.

В командной строке Linux я определил последовательный порт платы JTAGulator и установил с ним соединение через picocom, минималистичную программу эмуляции терминала ввода-вывода. Она отлично справляется с получением доступа к консоли Linux с последовательным портом.

Установка picocom:

В Ubuntu можно просто прописать:

**`sudo apt-get install picocom`**

Выдержка из инструкций по быстрому запуску:  

[**https://www.parallax.com/sites/default/files/downloads/32115-JTAGulator-Product-Brief-1.1.pdf**](https://www.parallax.com/sites/default/files/downloads/32115-JTAGulator-Product-Brief-1.1.pdf)

JTAGulator питается от USB-порта компьютера и использует микросхему FT232RL \(промышленный стандарт FTDI\) для обеспечения подключения по USB \(драйверы можно скачать по ссылке[ www.ftdichip.com/Drivers/VCP.htm](http://www.ftdichip.com/Drivers/VCP.htm).\) Устройство будет отображаться как виртуальный COM-порт. Ему будет автоматически присвоен номер COM-порта.

**Характеристики соединения:** 115200 бит/с, 8 бит данных, без контроля четности, 1 стоп-бит.

Для связи с JTAGulator используется программа-терминал \(к примеру, HyperTerminal, PuTTY, CoolTerm, picocom или screen\).

`$ dmesg | grep tty    (определяем порт)`

`$  sudo picocom -b 115200 -r -l /dev/ttyUSB0     (-b = скорость (бод), -r = не сбрасывать, -l = не блокировать)`

![](../../.gitbook/assets/image%20%28210%29.png)

При нажатии \[ENTER\] появляется командная строка JTAGulator ‘:’

**: H** \(выводит доступные команды\)

**Набор команд** \(начиная с версии прошивки 1.1.1.\)

Все команды являются однобайтовыми печатаемыми значениями ASCII не чувствительными к регистру \(будет работать как верхний, так и нижний регистры\). Каждая команда должна заканчиваться одним CR или LF \(некоторые терминальные программы при нажатии Enter отправляют оба байта, поэтому проверьте настройки, если JTAGulator работает некорректно\).

**JTAG:**          I       - Обнаружение распиновки JTAG \(сканирование IDCODE\)

                     B     - Обнаружение распиновки JTAG \(сканирование BYPASS\)

                     D     - Получение ID устройств\(а\)

                     T      - Тестирование BYPASS

**UART:**       U     - Обнаружение распиновки UART

                     P      - Ретрансляция UART

**Общие:**      V     - Задать целевое напряжение \(от 1.2 до 3.3В\)

                     R     - Считывание всех каналов \(ввод\)

                     W    - Запись всех каналов \(вывод\)

                     H     - Вывести доступные команды

Прежде чем продолжить, мне нужно было определить напряжение \(логический уровень\) целевого устройства. Я сделал это с помощью мультиметра, настроенного для измерения постоянного напряжения и проверки различных точек целевой платы \(включая разъем, который я припаял ранее\). Логический уровень, используемый в данной плате был 3.3В.

**: V Задать целевое напряжение \(от 1.2 до 3.3В\)**

![&#x41F;&#x435;&#x440;&#x435;&#x432;&#x43E;&#x434; &#x442;&#x435;&#x43A;&#x441;&#x442;&#x430; &#x441; &#x43A;&#x430;&#x440;&#x442;&#x438;&#x43D;&#x43A;&#x438; - &#x43D;&#x438;&#x436;&#x435;](../../.gitbook/assets/image%20%28217%29.png)

`: v`

`Текущее целевое напряжение ввода-вывода: не определено`

`Задайте новое целевое напряжение ввода-вывода (от 1.2 до 3.3В, и 0 для ОТКЛ.): 3.3`

`Новое установленное целевое напряжение ввода-вывода: 3.3`

`Убедитесь, что VADJ НЕ подключен к целевому устройству`

Перед выполнением команды **Обнаружение распиновки JTAG \(сканирование BYPASS\),** я выполнил другую - **Обнаружение распиновки JTAG \(сканирование IDCODE\)** 

_Команда Сканирование для получения кода ID выполняется значительно быстрее, чем Bypass-сканирование \(команду TDI выполнять не требуется, что позволяет избежать большого количества взаимных перестановок групп каналов\), хотя сканирование для получения ID помогает найти только 3 из необходимых 4 контактов JTAG._

**: I Обнаружение распиновки JTAG \(сканирование IDCODE\)**

![&#x41F;&#x435;&#x440;&#x435;&#x432;&#x43E;&#x434; &#x442;&#x435;&#x43A;&#x441;&#x442;&#x430; &#x441; &#x43A;&#x430;&#x440;&#x442;&#x438;&#x43D;&#x43A;&#x438; - &#x43D;&#x438;&#x436;&#x435;](../../.gitbook/assets/image%20%28215%29.png)

`: i`

`Введите необходимое для использования количество каналов (от 3 до 24): 8`

`Убедитесь, что на каналах с CH7 по СH0 есть контакт.`

`Возможные взаимные перестановки групп каналов: 336`

`Чтобы начать, нажмите «пробел» (для отмены нажмите любую клавишу)…`

`JTAGulating! Нажмите любую клавишу для отмены…`

`TDI: нет`

`TDI: 1`

`TCK: 2`

`TMS: 3`

`…`

`Сканирование IDCODE завершено!`

Выполнение команды **Получение ID устройства** позволяет сделать следующее…

**: D Получение ID устройства** 

![&#x41F;&#x435;&#x440;&#x435;&#x432;&#x43E;&#x434; &#x442;&#x435;&#x43A;&#x441;&#x442;&#x430; &#x441; &#x43A;&#x430;&#x440;&#x442;&#x438;&#x43D;&#x43A;&#x438; - &#x43D;&#x438;&#x436;&#x435;](../../.gitbook/assets/image%20%28209%29.png)

`: d`

`Для получения ID устройства TDI не требуется.`

`Установите новый контакт TDO [0]: 1`

`Установите новый контакт TCK [0]: 2`

`Установите новый контакт TMS [0]: 3`

`Введите необходимое число устройств в цепи JTAG [0]: 8`

`Все прочие каналы заданы на вывод логического уровня 1 (HIGH).`

`ID устройства №1: 0001 1111000011110000 11110000111 1 (0x1F0F0F0F)`

`-> ID производителя: 0x787`

`-> Номер устройства: 0xF0F0`

`-> Версия: 0х1`

`Составление списка IDCODE завершено!`

Выполнение команды **Обнаружение распиновки JTAG \(сканирование BYPASS\)** позволяет распознать все 4 необходимых контакта JTAG \(и опциональный контакт TRST\).

**: B Обнаружение распиновки JTAG \(сканирование BYPASS\)** 

![](../../.gitbook/assets/image%20%28213%29.png)

`: b`

`Введите необходимое для использования количество каналов (от 4 до 24): 8`

`Убедитесь, что на каналах с CH7 по СH0 есть контакт.`

`Возможные взаимные перестановки групп каналов: 1680`

`Чтобы начать, нажмите «пробел» (для отмены нажмите любую клавишу)…………`

`JTAGulating! Нажмите любую клавишу для отмены…`

`TDI: 4`

`TDI: 1`

`TCK: 2`

`TMS: 3`

`Количество обнаруженных устройств: 1`

`………………………………………`

`Сканирование BYPASS завершено!`

Выполнение команды **Тестирование BYPASS \(TDI TDO\)** позволяет проверить, что все 32 бит случайных данных, переданных TDO на целевое устройство корректно возвращаются обратно на TDO устройства JTAGulator.

**: T Тестирование BYPASS \(TDI TDO\)**

![&#x41F;&#x435;&#x440;&#x435;&#x432;&#x43E;&#x434; &#x442;&#x435;&#x43A;&#x441;&#x442;&#x430; &#x441; &#x43A;&#x430;&#x440;&#x442;&#x438;&#x43D;&#x43A;&#x438; - &#x43D;&#x438;&#x436;&#x435;](../../.gitbook/assets/image%20%28212%29.png)

`: t`

`Установите новый контакт TDI [0]: 4`

`Установите новый контакт TDO [0]: 1`

`Установите новый контакт TCK [0]: 2`

`Установите новый контакт TMS [0]: 3`

`Введите необходимое число устройств в цепи JTAG [8]: 1`

`Все прочие каналы заданы на вывод логического уровня 1 (HIGH).`

`Шаблон ввода на TDI: 11100010100001001000000010110000`

`Шаблон вывода с TDI: 11100010100001001000000010110000`

`Совпадение!`

`: t`

`Установите новый контакт TDI [4]:`

`Установите новый контакт TDO [1]:`

`Установите новый контакт TCK [2]:`

`Установите новый контакт TMS [3]:`

`Введите необходимое число устройств в цепи JTAG [1]:`

`Все прочие каналы заданы на вывод логического уровня 1 (HIGH).`

`Шаблон ввода на TDI: 10001101111011001110101101100110`

`Шаблон вывода с TDI: 10001101111011001110101101100110`

`Совпадение!`

`: t`

`Установите новый контакт TDI [4]:`

`Установите новый контакт TDO [1]:`

`Установите новый контакт TCK [2]:`

`Установите новый контакт TMS [3]:`

`Введите необходимое число устройств в цепи JTAG [1]:`

`Все прочие каналы заданы на вывод логического уровня 1 (HIGH).`

`Шаблон ввода на TDI: 01001011010111010000101110110011`

`Шаблон вывода с TDI: 01001011010111010000101110110011`

`Совпадение!`

**`:`**

## **Резюмируя**

Применение JTAGulator для обнаружения контактов JTAG всегда будет бесценным инструментом. Настоятельно его рекомендую. Зная распиновку JTAG, подключив JTAG-совместимый USB-адаптер и воспользовавшись несколькими хорошими и проверенными инструментами отладки \(OpenOCD, GDB, binwalk и т.д.\), можно успешно взаимодействовать с целевым оборудованием.

В заключение можно с уверенностью сказать, что производители вскоре осознают, что для защиты собственных интересов стоит скрывать эти средства отладки и тестирования \(TAP\). Данные инструменты существуют уже давно и не думаю, что исчезнут в ближайшее время, поскольку играют важную роль в производственном цикле. Применение вышеупомянутых методов наряду с получением соответствующих схем систем на кристалле поможет обнаружить и более тщательно скрытые TAP. Во многих случаях можно просто посмотреть внимательно на пространство вокруг чипа и найти необходимые зацепки. В остальных ситуациях TAP могут скрываться под изучаемыми системами на кристалле, что требует демонтажа чипа. Потенциальные контрольные точки для тестирования можно найти, кроме того, изучив дорожки на плате, насколько бы трудно это ни было.

