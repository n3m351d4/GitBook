# MQTT – Нервная Система IoT

_Перевод: @N3M351DA_

 _Источник:_ [_http://blog.catchpoint.com/2017/05/30/protocol-for-internet-of-things/_ ](http://blog.catchpoint.com/2017/05/30/protocol-for-internet-of-things/)

![http://blog.catchpoint.com/wp-content/uploads/2017/05/MQTT-internet-of-things.jpg](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017.jpeg)

Сегодня в нашем мире существуют миллиарды интеллектуальных устройств, но что было бы, если эти устройства были взаимосвязаны? Что если эти устройства могли бы взаимодействовать друг с другом так же, как это делают их владельцы, образуя глобальную нервную систему? По сути, это описывает то, что сегодня люди называют Интернетом вещей или IoT. IoT произвел революцию в мире информационных технологий и внедрении инноваций. Углубляясь в IoT необходимо учитывать все, начиная от производительности и заканчивая безопасностью.

**Message Queueing Telemetry Transport Protocol \(MQTT\)**

MQTT – это облегченный протокол обмена сообщениями на основе модели публикации-подписки для обмена данными между компьютерами \(M2M\) поверх протокола TCP / IP. Протокол обеспечивает технологию телеметрии, и разработчики MQTT работают над тем, чтобы соединить развивающийся мир интернета, который, как ожидается, будет производить еще больше разнообразных интеллектуальных устройств. Первая версия протокола MQTT была разработана Стэнфорд-Кларком, IBM и Арленом Ниппером.

**Почему MQTT?**

MQTT используется Facebook для приложения Messenger, которому требуется постоянное подключение к своим серверам без потери заряда батареи. Он так же требует стабильной работы при низкой пропускной способности сети и имеет небольшой объем кода. Подобные функции являются преимуществами для устройств с небольшим объемом памяти и вычислительной мощности.

Другие примечательные особенности MQTT:

* Открытый исходный код, отсутствие лицензионных платежей и, следовательно, легкость введения в использование и адаптации
* Следует модели публикации-подписки и «один-ко-многим»
* Имеет небольшие заголовки сообщений
* Имеет несколько уровней качества обслуживания
* Имеет простые командные сообщения
* Не зависит от типа данных
* Возможность отложенного получения сообщений для новых клиентов
* Механизм поддержания продолжительных клиентских сессий
* Механизм уведомления клиентов при потере соединения \(LWT\)

**MQTT vs. HTTP**

![](http://dc7495.org/aybbtu/uploads/2020/04/word-image-64.png)

Пример топологии MQTT:

![http://blog.catchpoint.com/wp-content/uploads/2017/05/Screen-Shot-2017-05-30-at-11.55.30-AM.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017.png)

**Уровни качества обслуживания**

Значение QoS определяет способ доставки каждого сообщения, и является обязательным значением для каждого отправляемого сообщения.

**QoS 0 \(не более одной попытки доставки сообщения\)**

Когда для сообщения установлено значение QoS, равное 0, ответ не ожидается, и правила повторных попыток его отправления не определены. Сообщение приходит брокеру либо один раз, либо совсем не поступает. Сообщение QoS 0 теряется, если клиент отключен или произошел сбой сервера. MQTT не повторяет попытку отправки. С точки зрения производительности — это самый быстрый способ отправки сообщения с использованием MQTT. Здесь используется команда MQTT PUBLISH и никакие другие команды не передаются для сообщения QoS 0.

![http://blog.catchpoint.com/wp-content/uploads/2017/05/Screen-Shot-2017-05-30-at-11.58.21-AM.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-1.png)

**QoS 1 \(минимум одна доставка сообщения\)**

Клиент или сервер MQTT попытается доставить сообщение хотя бы один раз, при этом появляется возможность дублирования сообщений. Когда брокер получает сообщение, отправляется подтверждение PUBACK. Если PUBACK не получен, отправитель снова отправляет сообщение с установленным битом DUP \(дубликата\). Получив сообщение с установленным битом DUP, посредник повторно публикует сообщение всем своим подписчикам и отправляет другое сообщение PUBACK. Таким образом может быть достигается устойчивость соединения MQTT. Когда происходит PUBLISH, сообщение сохраняется на постоянном уровне, таком как диск, и удаляется при получении PUBACK. Сообщение с QoS 1 имеет идентификатор сообщения в заголовке сообщения.

![http://blog.catchpoint.com/wp-content/uploads/2017/05/Screen-Shot-2017-05-30-at-11.59.18-AM.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-2.png)

**QoS 2 \(доставка только одного сообщения\)**

Дополнительные потоки к QoS 1 гарантируют, что сообщение доставляется ровно один раз. Сообщение отправляется в потоке PUBLISH, и сообщение сохраняется клиентом. Сообщение PUBREC отправляется как ответ на PUBLISH. Между тем сообщение заблокировано на сервере. При получении PUBREC PUBREL отправляется на сервер. Получив PUBREL, брокер отправляет сообщения, отправляет PUBCOMP и сбрасывает сохраненное состояние. Сообщение с QoS 2 будет иметь идентификатор сообщения в заголовке сообщения.

![http://blog.catchpoint.com/wp-content/uploads/2017/05/Screen-Shot-2017-05-30-at-12.01.31-PM.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-3.png)

**Безопасность в MQTT**

MQTT нацелен на создание облегченной связи для Интернета вещей, но для подобных протоколов безопасность обходится дорого с точки зрения задействования производительности процессора и канала связи. Это является причиной того, почему в протоколе доступно всего несколько механизмов безопасности. Но в то же время, многие реализации MQTT имеют стандарты безопасности, такие как SSL / TLS.

Безопасность в MQTT подразделяется на несколько уровней.

**Сетевой уровень**: обеспечение безопасного соединения за счет использования физически защищенной сети или VPN.

**Транспортный уровень**: использование TLS / SSL для транспортного шифрования, которое обеспечивает защищенную передачу данных и аутентификацию.

**Уровень приложения**: протокол имеет идентификатор клиента, имя пользователя / пароль, используемые для аутентификации устройства. Другим способом является шифрование полезной нагрузки без использования расширенного транспортного шифрования.

**MQTT в действии**

**Решение для домашнего мониторинга**

Классическим примером для приложения на основе MQTT является система домашнего мониторинга. Например, система, определяющая текущую температуру комнатного обогревателя и отправляющая эту информацию на устройство по запросу.

![http://blog.catchpoint.com/wp-content/uploads/2017/05/Screen-Shot-2017-05-30-at-1.22.22-PM.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-4.png)

Как и в любом приложении, в котором существует связь между клиентами, здесь существует вероятность сетевых или программных сбоев. Поэтому очень важно отслеживать корректность функционирования приложения.

Мы можем отслеживать производительность и доступность устройств IoT, используя протокол MQTT. Для отправки сообщений публикации/подписки через MQTT, можно использовать тест MQTT. Публикуя и подписываясь на сообщения определенной темы и можно измерить сколько времени это займет.

![http://blog.catchpoint.com/wp-content/uploads/2017/05/Screen-Shot-2017-05-30-at-1.23.50-PM.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-5.png)

В следующем посте мы рассмотрим протокол MQTT с помощью Wireshark. Это поможет нам понять связь между клиентом MQTT и брокером MQTT.

## **Изучение MQTT с использованием Wireshark**

_Перевод: @N3M351DA_

_Источник:_ [_http://blog.catchpoint.com/2017/07/06/dissecting-mqtt-using-wireshark/_ ](http://blog.catchpoint.com/2017/07/06/dissecting-mqtt-using-wireshark/)

![http://blog.catchpoint.com/wp-content/uploads/2017/06/MQTT-Wireshark.jpg](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-1.jpeg)

Ранее мы рассмотрели протокол MQTT, как он работает и его роль в цифровом мире. Чтобы лучше понять содержание этой статьи, ознакомьтесь с основами межмашинного взаимодействия \(M2M\) в предыдущей статье «MQTT – Нервная Система IoT». Мы будем использовать монитор MQTT для отправления сообщений подписки/публикации от брокера MQTT. Изображение ниже иллюстрирует тест, настроенный с использованием [Catchpoint ](https://www.catchpoint.com/).

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt1.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-6.png)

Метрики мониторинга MQTT Catchpoint включают в себя время публикации, размер публикации, время подписки, размер подписки, DNS и время соединения.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt2.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-7.png)

Чтобы интерпретировать данные, собранные с помощью мониторинга MQTT, вам нужно разобраться, что происходит при передаче сетевого траффика, это можно сделать с помощью Wireshark. Такие инструменты, как Wireshark, позволяют анализировать каждый шаг процесса и проверять пакеты данных. В этом анализе мы будем использовать монитор Catchpoint MQTT, чтобы настроить пробный тест.

**Анализ с использованием Wireshark**

Протокол MQTT основан на TCP / IP, и клиент и брокер должны поддерживать стек TCP / IP.

Ниже приведено изображение подписки с последующей публикацией в том же брокере MQTT. Мы будем рассматривать сообщение с уровнем доставки QoS t0. Давайте проанализируем сообщения, передаваемые с использованием этого протокола.

![http://blog.catchpoint.com/wp-content/uploads/2017/07/mqtt3.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-8.png)

Примечание. На изображении выше IP 192.168.0.11 – это IP-адрес брокера MQTT, а 192.168.0.12 – действует как клиент публикации и клиент подписки.

**1. Connect Message**

Соединение MQTT производится между клиентом и брокером и никогда напрямую с другим клиентом. Инициация этого соединения происходит с помощью команды CONNECT, отправляемой от клиента брокеру. Установленное соединение остается открытым до тех пор, пока не получит команду разъединения от клиента.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt4.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-9.png)

Порт 1883 является портом по умолчанию для реализации протокола MQTT с помощью TCP.

Порт 8883 предназначен для реализации протокола MQTT с использованием TLS.

Рассмотрим детали сообщения подключения:

_**• Флаги заголовка:**_ содержат информацию о типе пакета управления MQTT.

_**• Флаги соединения:**_ байты флага соединения содержат параметры, определяющие поведение соединения MQTT. Он обозначает наличие или отсутствие полей в полезной нагрузке.

• _**Clean session:**_ первый бит флагов соединения. Этот флаг указывает посреднику, хочет ли клиент установить постоянное соединение или нет. Если установлено значение «истина», результатом является сеанс, при котором подписки удаляются при отключении, а при значении «ложь» может быть достигнуто надежное соединение, когда сообщения с высоким QoS доставляются при повторном подключении.

• _**Will flag:**_ второй бит флагов соединения. Часть механизма уведомления клиентов при потере соединения. При установке этот флаг означает, что, если запрос на соединение принят, на сервере должно быть сохранено сообщение Will. Сообщение Will – это сообщение MQTT с темой Will и сообщением Will. Оно используется при уведомлении других клиентов об отключении. Когда клиент отключается, брокер отправляет это сообщение от его имени. Когда флаг Will установлен в 1, серверы будут использовать поля Will QoS и Will Retain в флагах Connect.

• _**Will QoS:**_ биты 4 и 3 флагов подключения. Обозначают уровень QoS, который будет использоваться при публикации сообщения Will.

• _**Will retain:**_ Пятый бит флагов подключения. Если для параметра Will Retain установлено значение 0, сервер должен опубликовать сообщение Will без сохранения, а когда оно установлено в 1, сообщение Will публикуется как сообщение с сохранением.

• _**User Name and Password:**_ биты 7 и 6 флагов подключения. Когда эти поля установлены, сервер будет ожидать учетные данные в полезной нагрузке. MQTT позволяет отправлять имя пользователя и пароль для аутентификации клиента и авторизации. Пароль отправляется в виде открытого текста, если он не зашифрован.

• _**Keep alive:**_ Таймер поддержания активности используется для определения того, находится ли клиент MQTT в сети, для этого клиент отправляет брокеру регулярные сообщения запроса PING, а брокер отвечает PING-ответом.

• _**Client ID:**_ идентификатор клиента MQTT, подключающегося к брокеру MQTT. Он должен быть уникальным для каждого брокера.

• _**Payload:**_ полезная нагрузка содержит поля «Идентификатор клиента», «Тема», «Сообщение», «Имя пользователя» и «Пароль», наличие которых определяется флагами.

**2. Connect Acknowledgment Message**

Получив сообщение CONNECT, брокер отвечает сообщением CONNACK.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt5.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-10.png)

• _**Header Flags**_**:** содержит информацию о типе пакета управления MQTT.

• _**Session Present:**_ бит 0 байта Connection Ack, является флагом присутствия сеанса. Этот флаг указывает, имеет ли брокер открытый сеанс клиента из предыдущих взаимодействий.

• _**Return Code**_: значения кода ответа и ответ в таблице ниже

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt6.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-11.png)

• _**Payload:**_ пакет CONNACK не имеет полезной нагрузки.

**3. Subscribe Message**

Клиент отправляет сообщение SUBSCRIBE брокеру MQTT для получения соответствующих ему сообщений.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt7.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-12.png)

• _**Header Flags**_: содержат информацию о типе пакета управления MQTT.

• _**Message Identifier**_: идентификатор между клиентом и брокером, служит для идентификации сообщения в потоке сообщений. Актуально для QoS выше нуля.

• _**Topic and QoS Level:**_ Каждая подписка и тема представляет собой пару для фильтра тем и уровня QoS. Тема является предметом интереса клиента, который хотел бы получать сообщения о ней.

• _**Payload**_: полезная нагрузка содержит список подписок. Список подписок должен быть обязательно перечислен в пакете SUBSCRIBE.

**4. Subscribe Acknowledgement Message**

Брокер MQTT подтверждает подписку, отправляя подтверждение обратно клиенту в сообщении SUBACK.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt8.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-13.png)

• _**Header Flags:**_ содержат информацию о типе пакета управления MQTT.

• _**Message Identifier:**_ актуально для сообщения с QoS больше нуля, аналогичным указанному в сообщении SUBSCRIBE.

• _**Return Code**_: MQTT-брокер отправляет код ответа для каждой пары Тема / QoS, полученной в сообщении SUBSCRIBE. Код ответа соответствует уровню QoS в случае успеха. Значения кода ответа приведены в таблице ниже.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt9.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-14.png)

• _**Payload:**_ полезная нагрузка содержит список кодов ответа.

**5. Publish Message**

Как только клиент MQTT подключен к брокеру, он может публиковать сообщения.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt10.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-15.png)

• _**Header Flags:**_ Содержат информацию о типе пакета управления MQTT.

• _**DUP flag:**_ Если флаг DUP равен 0, это означает, что это первая попытка отправки пакета PUBLISH. Если флаг равен 1, это указывает на повторную попытку отправки сообщения.

• _**QoS**_: Уровень QoS определяет уровень достоверности сообщения.

• _**Retain Flag:**_ Если данный флаг установлен в 1, сервер должен сохранить сообщение и его QoS, чтобы в дальнейшем обслуживать будущие подписки, соответствующие теме. Когда пакет PUBLISH отправляется подписывающемуся клиенту, сервер устанавливает Retain Flag в 1. Сервер устанавливает флаг сохранения в 0 при отправке пакета, если он соответствует установленной подписке, независимо от того, был ли установлен флаг при получении сообщения.

• _**Topic Name:**_ Строка UTF-8, которая также может содержать косую черту, если она иерархически структурирована. Публикуемое сообщение должно содержать тему, которая используется брокером для фильтрации по темам. Таким образом, брокер будет отправлять сообщения клиентам, которые подписались на указанную тему.

• _**Message**_: Полезная нагрузка вместе с темой, которая содержит фактические данные для передачи. Поскольку MQTT не зависит от передаваемых данных, полезная нагрузка может быть структурирована на основе варианта использования.

• _**Payload**_: Содержит публикуемое сообщение.

**6. Disconnect Request Message:**

Сообщение об отключении – это окончательный контрольный пакет, отправленный клиентом брокеру, оно означает отключение клиентом от брокера.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt11.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-16.png)

• _**Header Flags:**_ содержат информацию о типе пакета управления MQTT.

• _**Payload:**_ пакет отключения не имеет полезной нагрузки.

**7. MQTT Keep Alive**

Функция поддержания активности \(Keep Alive\) гарантирует, что соединение открыто, а клиент и брокер связаны друг с другом. Когда соединение установлено, интервал поддержания активности \(в секундах\) передается брокеру клиентом.

В спецификации MQTT говорится:

_«Клиент отвечает за то, чтобы интервал между отправляемыми контрольными пакетами не превышал значения Keep Alive. При отсутствии отправки каких-либо других управляющих пакетов клиент должен отправить пакет PINGREQ»._

Поток Keep Alive поддерживается сообщениями PINGREQ и PINGRESP.

Типичный поток поддержания активности показан на рисунке ниже.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt12.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-17.png)

**PINGREQ**

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt13.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-18.png)

PINGREQ посылается клиентом брокеру, чтобы показать, что он все еще активен, не смотря на то, что он не отправлял других пакетов управления MQTT. Если посредник не получает PINGREQ или какой-либо другой пакет, он закрывает соединение и отправляет сообщение LWT, если клиент его указал ранее.

• _**Header Flags**_: содержат информацию о типе пакета управления MQTT.

• _**Payload**_**:** пакет PINGREQ не имеет полезной нагрузки.

**PINGRESP**

PINGRESP – это ответ, который брокер отправляет в ответ на полученный пакет PINGREQ. Это указывает на доступность брокера для клиента.

![http://blog.catchpoint.com/wp-content/uploads/2017/06/mqtt14.png](http://dc7495.org/aybbtu/uploads/2020/04/http-blog-catchpoint-com-wp-content-uploads-2017-19.png)

**•** _**Header Flags**:_ содержат информацию о типе пакета управления MQTT.

**•** _**Payload**_: пакет PINGRESP не имеет полезной нагрузки.

**Заключение**

MQTT стимулирует инновации в сфере IoT и становится неотъемлемой частью цифрового мира. Предыдущий пост о MQTT дал нам обзор протокола, а в этой статье мы рассмотрели различные процессы, связанные с взаимодействием между клиентом MQTT и брокером MQTT с помощью Wireshark. Понимание этих метрик и рабочего процесса поможет вам быстро выявить проблемы, связанные с MQTT.

